; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\..\build\bootloader\emw3162\obj_rvmdk\patch_keil.o --asm_dir=..\..\..\Build\Bootloader\EMW3162\List_RVMDK\ --list_dir=..\..\..\Build\Bootloader\EMW3162\List_RVMDK\ --depend=..\..\..\build\bootloader\emw3162\obj_rvmdk\patch_keil.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=1,1293 -I..\..\..\include -I..\..\..\Platform\Common\Cortex-M4\CMSIS -I..\..\..\Platform\Common\Cortex-M4\STM32F4xx\STM32F4xx_Drv -I..\..\..\Platform\Common\Cortex-M4\STM32F4xx -I..\..\..\Platform\Common\Cortex-M4 -I..\..\..\Platform\Common\Cortex-M4\STM32F4xx\STM32F4xx_Drv\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\Bootloader -I..\..\..\MICO -I..\..\..\Platform\EMW3162 -I..\..\..\External -I..\..\..\Library\support -I..\..\..\Platform\include -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.1\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\1.0.6\Device\Include -D__MICROLIB -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DBOOTLOADER -DSIZE_OPTIMIZE ..\..\..\Platform\IDEs\Keil\patch_keil.c]
                          THUMB

                          AREA ||i.__data_GetMemChunk||, CODE, READONLY, ALIGN=1

                  __data_GetMemChunk PROC
;;;120    
;;;121    int __data_GetMemChunk(void)
000000  2000              MOVS     r0,#0
;;;122    {
;;;123    	return 0;
;;;124    }
000002  4770              BX       lr
;;;125    
                          ENDP


                          AREA ||i.__iar_Strstr||, CODE, READONLY, ALIGN=1

                  __iar_Strstr PROC
;;;81     // logging.o
;;;82     char* __iar_Strstr(char* s1, char* s2)
000000  b510              PUSH     {r4,lr}
;;;83     {  
;;;84         int n;  
;;;85         if (*s2)  
000002  780a              LDRB     r2,[r1,#0]
000004  b962              CBNZ     r2,|L2.32|
                  |L2.6|
;;;86         {  
;;;87             while (*s1)  
;;;88             {  
;;;89                 for (n=0; *(s1 + n) == *(s2 + n); n++)  
;;;90                 {  
;;;91                     if (!*(s2 + n + 1))  
;;;92                         return (char *)s1;  
;;;93                 }  
;;;94                 s1++;  
;;;95             }  
;;;96             return NULL;  
;;;97         }  
;;;98         else  
;;;99             return (char *)s1;  
;;;100    }  
000006  bd10              POP      {r4,pc}
                  |L2.8|
000008  2200              MOVS     r2,#0                 ;89
00000a  e004              B        |L2.22|
                  |L2.12|
00000c  188b              ADDS     r3,r1,r2              ;91
00000e  785b              LDRB     r3,[r3,#1]            ;91
000010  2b00              CMP      r3,#0                 ;91
000012  d0f8              BEQ      |L2.6|
000014  1c52              ADDS     r2,r2,#1              ;91
                  |L2.22|
000016  5c83              LDRB     r3,[r0,r2]            ;89
000018  5c8c              LDRB     r4,[r1,r2]            ;89
00001a  42a3              CMP      r3,r4                 ;89
00001c  d0f6              BEQ      |L2.12|
00001e  1c40              ADDS     r0,r0,#1              ;89
                  |L2.32|
000020  7802              LDRB     r2,[r0,#0]            ;87
000022  2a00              CMP      r2,#0                 ;87
000024  d1f0              BNE      |L2.8|
000026  2000              MOVS     r0,#0                 ;96
000028  bd10              POP      {r4,pc}
;;;101    //mxchipWNET.o
                          ENDP


                          AREA ||i._sys_command_string||, CODE, READONLY, ALIGN=1

                  _sys_command_string PROC
;;;53     
;;;54     char *_sys_command_string(char * cmd, int len) 
000000  2000              MOVS     r0,#0
;;;55     {
;;;56         cmd = cmd;
;;;57         len = len;
;;;58         return 0;
;;;59     }
000002  4770              BX       lr
;;;60     
                          ENDP


                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
                  |L4.0|
;;;43     
;;;44     void _sys_exit(int return_code) {
000000  e7fe              B        |L4.0|
;;;45     label:  goto label;  /* endless loop */
;;;46     }
;;;47     
                          ENDP


                          AREA ||i._ttywrch||, CODE, READONLY, ALIGN=1

                  _ttywrch PROC
;;;38     
;;;39     void _ttywrch(int ch) {
000000  4770              BX       lr
;;;40       return;
;;;41     }
;;;42     
                          ENDP


                          AREA ||i.aes_decrypt||, CODE, READONLY, ALIGN=1

                  aes_decrypt PROC
;;;105    
;;;106    int aes_decrypt(void)
000000  2000              MOVS     r0,#0
;;;107    {
;;;108        return 0;
;;;109    }
000002  4770              BX       lr
;;;110    
                          ENDP


                          AREA ||i.ferror||, CODE, READONLY, ALIGN=1

                  ferror PROC
;;;32     
;;;33     int ferror(FILE *f) {
000000  f04f30ff          MOV      r0,#0xffffffff
;;;34       /* Your implementation of ferror */
;;;35       return EOF;
;;;36     }
000004  4770              BX       lr
;;;37     
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;27     
;;;28     int fgetc(FILE *f) {
000000  2030              MOVS     r0,#0x30
;;;29       return 0x30;
;;;30     }
000002  4770              BX       lr
;;;31     
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;47     
;;;48     int fputc(int ch, FILE *f) {
000000  b513              PUSH     {r0,r1,r4,lr}
;;;49       MicoUartSend( STDIO_UART, &ch, 1 );
000002  2201              MOVS     r2,#1
000004  4669              MOV      r1,sp
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       MicoUartSend
;;;50       return ch;
00000c  9800              LDR      r0,[sp,#0]
;;;51     }
00000e  bd1c              POP      {r2-r4,pc}
;;;52     
                          ENDP


                          AREA ||i.is_nfc_up||, CODE, READONLY, ALIGN=1

                  is_nfc_up PROC
;;;101    //mxchipWNET.o
;;;102    int is_nfc_up(void){
000000  2000              MOVS     r0,#0
;;;103        return 0;
;;;104    }
000002  4770              BX       lr
;;;105    
                          ENDP


                          AREA ||i.nfc_config_stop||, CODE, READONLY, ALIGN=1

                  nfc_config_stop PROC
;;;110    
;;;111    int nfc_config_stop(void)
000000  2000              MOVS     r0,#0
;;;112    {
;;;113        return 0;
;;;114    }
000002  4770              BX       lr
;;;115    
                          ENDP


                          AREA ||i.uart_init||, CODE, READONLY, ALIGN=1

                  uart_init PROC
;;;115    
;;;116    int uart_init(void)
000000  2000              MOVS     r0,#0
;;;117    {
;;;118        return 0;
;;;119    }
000002  4770              BX       lr
;;;120    
                          ENDP


                          AREA ||i.wiced_platform_get_rtc_time||, CODE, READONLY, ALIGN=1

                  wiced_platform_get_rtc_time PROC
;;;125    
;;;126    int wiced_platform_get_rtc_time (){
000000  2001              MOVS     r0,#1
;;;127        return 1;
;;;128    }
000002  4770              BX       lr
;;;129    int wiced_platform_set_rtc_time (){
                          ENDP


                          AREA ||i.wiced_platform_set_rtc_time||, CODE, READONLY, ALIGN=1

                  wiced_platform_set_rtc_time PROC
;;;128    }
;;;129    int wiced_platform_set_rtc_time (){
000000  2000              MOVS     r0,#0
;;;130        return 0;
;;;131    }
000002  4770              BX       lr
;;;132    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000

                          AREA ||area_number.18||, DATA, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.data||
                  __stdin
                          DCD      0x00000000

                          AREA ||area_number.19||, DATA, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.data||
                  __stderr
                          DCD      0x00000000
