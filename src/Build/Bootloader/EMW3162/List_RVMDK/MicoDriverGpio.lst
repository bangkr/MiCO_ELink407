L 1 "..\..\..\Platform\Common\Cortex-M3\STM32F2xx\MicoDriverGpio.c"
N/**
N******************************************************************************
N* @file    MicoDriverGpio.c 
N* @author  William Xu
N* @version V1.0.0
N* @date    05-May-2014
N* @brief   This file provide GPIO driver functions.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N
N#include "MICOPlatform.h"
L 1 "..\..\..\include\MICOPlatform.h" 1
N/**
N******************************************************************************
N* @file    MicoDefault.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    16-Sep-2014
N* @brief   This file provides all the headers of MICO peripheral operations. 
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N#ifndef __MICOPLATFORM_H__
N#define __MICOPLATFORM_H__
N
N#pragma once
N
N#include "common.h"
L 1 "..\..\..\Library\support\common.h" 1
N/**
N******************************************************************************
N* @file    Common.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    05-May-2014
N* @brief   This header contains common defines, macros and functions to be 
N           shared throughout the MICO project.
N******************************************************************************
N* @attention
N*
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N* TIME. AS A RESULT, MXCHIP Inc. SHALL NOT BE HELD LIABLE FOR ANY
N* DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N* FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N* CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*
N* <h2><center>&copy; COPYRIGHT 2014 MXCHIP Inc.</center></h2>
N******************************************************************************
N*/ 
N
N#ifndef __Common_h__
N#define __Common_h__
N
N// ==== STD LIB ====
N#include <stdint.h>
L 1 "d:\Keil_v5\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 180721 $
N * Checkin $Date: 2013-06-24 09:41:57 +0100 (Mon, 24 Jun 2013) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 28 "..\..\..\Library\support\common.h" 2
N#include <stdbool.h>
L 1 "d:\Keil_v5\ARM\ARMCC\bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5040049
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 29 "..\..\..\Library\support\common.h" 2
N#include <stdlib.h>
L 1 "d:\Keil_v5\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 180254 $
N * Checkin $Date: 2013-06-03 17:00:28 +0100 (Mon, 03 Jun 2013) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199901L)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_REALTIME_DIVIDE)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 30 "..\..\..\Library\support\common.h" 2
N#include <stdio.h>
L 1 "d:\Keil_v5\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 179217 $
N * Checkin $Date: 2013-03-12 14:03:19 +0000 (Tue, 12 Mar 2013) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 31 "..\..\..\Library\support\common.h" 2
N#include <string.h>
L 1 "d:\Keil_v5\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5040049
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 32 "..\..\..\Library\support\common.h" 2
N#include <ctype.h>
L 1 "d:\Keil_v5\ARM\ARMCC\bin\..\include\ctype.h" 1
N/* ctype.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.3 */
N/* Copyright (C) Codemist Ltd. 1988-1993.                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.03 */
N
N/*
N * RCS $Revision: 179217 $
N * Checkin $Date: 2013-03-12 14:03:19 +0000 (Tue, 12 Mar 2013) $
N * Revising $Author: agrant $
N */
N
N/*
N * ctype.h declares several functions useful for testing and mapping
N * characters. In all cases the argument is an int, the value of which shall
N * be representable as an unsigned char or shall equal the value of the
N * macro EOF. If the argument has any other value, the behaviour is undefined.
N */
N
N#ifndef __ctype_h
N#define __ctype_h
N#define __ARMCLIB_VERSION 5040049
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE_DEF inline
N#elif defined(__GNUC__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif 0L || (1L && 199901L <= 199901L)
N#define _ARMABI_INLINE_DEF static inline
N#elif defined(_USE_STATIC_INLINE)
S#define _ARMABI_INLINE_DEF static __inline
S#else
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N  #ifndef __CTYPE_DECLS
N  #define __CTYPE_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/* AEABI portable ctype flag bits */
N#define _ABI_A    1       /* alphabetic        */
N#define _ABI_X    2       /* A-F, a-f and 0-9  */
N#define _ABI_P    4       /* punctuation       */
N#define _ABI_B    8       /* blank             */
N#define _ABI_S   16       /* white space       */
N#define _ABI_L   32       /* lower case letter */
N#define _ABI_U   64       /* upper case letter */
N#define _ABI_C  128       /* control chars     */
N
N/* ARM internal ctype flag bits */
N/* N.B. - keep in step with <ctype.c> */
N
N/*
N * __ARM_CT_A (alphabetic) is required because characters in some locales
N * (e.g. Japanese) can be alphabetic but neither uppercase nor
N * lowercase. Unfortunately there wasn't a bit free for this, so
N * instead we've defined __ARM_CT_A as __ARM_CT_N+__ARM_CT_X (on the grounds that this
N * was a previously unused combination). Hence some of the ctype
N * predicates below are slightly less than obvious in
N * implementation.
N */
N#define __ARM_CT_S 1            /* whitespace           */
N#define __ARM_CT_P 2            /* punctuation          */
N#define __ARM_CT_B 4            /* blank                */
N#define __ARM_CT_L 8            /* lower case letter    */
N#define __ARM_CT_U 16           /* upper case letter    */
N#define __ARM_CT_N 32           /* (decimal) digit      */
N#define __ARM_CT_C 64           /* control chars        */
N#define __ARM_CT_X 128          /* A-F and a-f          */
N#define __ARM_CT_A (__ARM_CT_N+__ARM_CT_X)    /* alphabetic           */
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S
Sextern int (isalnum)(int /*c*/);
Sextern int (isalpha)(int /*c*/);
Sextern int (isblank)(int /*c*/);
Sextern int (iscntrl)(int /*c*/);
Sextern int (isdigit)(int /*c*/);
Sextern int (isgraph)(int /*c*/);
Sextern int (islower)(int /*c*/);
Sextern int (isprint)(int /*c*/);
Sextern int (ispunct)(int /*c*/);
Sextern int (isspace)(int /*c*/);
Sextern int (isupper)(int /*c*/);
Sextern int (isxdigit)(int /*c*/);
S
S/* Mandatory character attribute arrays indexed from 0 to 256 */
Sextern unsigned char const __aeabi_ctype_table_C[257];  /* "C" locale */
Sextern unsigned char const __aeabi_ctype_table_[257];   /* default locale */
S         /* The default locale might be the C locale */
S/* Optional character attribute arrays indexed from 0 to 256.        */
S/* These do not have to be provided by every execution environment   */
S/* but, if provided, shall be provided with these names and meaning. */
Sextern unsigned char const __aeabi_ctype_table_ISO8859_1[257];
Sextern unsigned char const __aeabi_ctype_table_SJIS[257];
Sextern unsigned char const __aeabi_ctype_table_BIG5[257];
Sextern unsigned char const __aeabi_ctype_table_UTF8[257];
S#ifdef _AEABI_LC_CTYPE
S# define _AEABI_CTYPE_TABLE(_X) __aeabi_ctype_table_ ## _X
S# define _AEABI_CTYPE(_X) _AEABI_CTYPE_TABLE(_X)
S# define __aeabi_ctype_table _AEABI_CTYPE(_AEABI_LC_CTYPE)
S#else
S# define __aeabi_ctype_table __aeabi_ctype_table_
S#endif
S
S#define isspace(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_S)
S#define isalpha(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_A)
S#define isalnum(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 30) /* test for _ABI_A and _ABI_X */
S#define isprint(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 28) /* test for _ABI_A, _ABI_X, _ABI_P and _ABI_B */
S#define isupper(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_U)
S#define islower(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_L)
S#define isxdigit(x) ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_X)
S#define isgraph(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 29) /* test for _ABI_A, _ABI_X and _ABI_P */
S#define iscntrl(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_C)
S#define ispunct(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_P)
S#define isdigit(c)  (((unsigned)(c) - '0') < 10)
S
N#else /* __AEABI_PORTABILITY_LEVEL */
N
Nextern _ARMABI_PURE unsigned char **__rt_ctype_table(void);
Xextern __declspec(__nothrow) __attribute__((const)) unsigned char **__rt_ctype_table(void);
N
N#define __arm_ctype (*__CLIBNS __rt_ctype_table())
N
N#ifdef __cplusplus
S    inline int isalnum(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N)); }
N#else
N    #define isalnum(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N))
N    extern int (isalnum)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic or numeric */
N
N#ifdef __cplusplus
S    inline int isalpha(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X)); }
N#else
N    #define isalpha(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X))
N    extern int (isalpha)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic */
N
N#ifdef __cplusplus
S    inline int iscntrl(int __c) { return (__arm_ctype[__c] & __ARM_CT_C); }
N#else
N    #define iscntrl(c) (__arm_ctype[c] & __ARM_CT_C)
N    extern int (iscntrl)(int /*c*/);
N#endif
N    /* non-0 iff c is a control character - in the "C" locale */
N    /*       this means (c < ' ') || (c > '~')                */
N
N/* isdigit must test for the presence of _only_ __ARM_CT_N, not just __ARM_CT_N at all. */
N#ifdef __cplusplus
S    inline int isdigit(int __c) { return (__arm_ctype[__c] == __ARM_CT_N); }
N#else
N    #define isdigit(c) (__arm_ctype[c] == __ARM_CT_N)
N    extern int (isdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a decimal digit */
N
N    extern int (isblank)(int /*c*/);
N    /* non-0 iff c is ' ', '\t' or some other locale-specific, */
N    /* word-separating character (there are no others in "C"   */
N    /* locale) */
N
N#ifdef __cplusplus
S    inline int isgraph(int __c) {return(__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P));}
N#else
N    #define isgraph(c) (__arm_ctype[c]&(__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P))
N    extern int (isgraph)(int /*c*/);
N#endif
N    /* non-0 iff c is any printing character other than ' ' */
N
N#ifdef __cplusplus
S    inline int islower(int __c) { return (__arm_ctype[__c] & __ARM_CT_L); }
N#else
N    #define islower(c) (__arm_ctype[c] & __ARM_CT_L)
N    extern int (islower)(int /*c*/);
N#endif
N    /* non-0 iff c is a lower-case letter */
N
N#ifdef __cplusplus
S    inline int isprint(int __c) { return (__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B)); }
N#else
N    #define isprint(c) (__arm_ctype[c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B))
N    extern int (isprint)(int /*c*/);
N#endif
N    /* non-0 iff c is a printing character - in the "C" locale */
N    /*       this means 0x20 (space) -> 0x7E (tilde)           */
N
N#ifdef __cplusplus
S    inline int ispunct(int __c) { return (__arm_ctype[__c] & __ARM_CT_P); }
N#else
N    #define ispunct(c) (__arm_ctype[c] & __ARM_CT_P)
N    extern int (ispunct)(int /*c*/);
N#endif
N    /* non-0 iff c is a non-space, non-alpha-numeric, printing character */
N
N#ifdef __cplusplus
S    inline int isspace(int __c) { return (__arm_ctype[__c] & __ARM_CT_S); }
N#else
N    #define isspace(c) (__arm_ctype[c] & __ARM_CT_S)
N    extern int (isspace)(int /*c*/);
N#endif
N    /* non-0 iff c is a white-space char: ' ', '\f', '\n', '\r', '\t', '\v'. */
N
N#ifdef __cplusplus
S    inline int isupper(int __c) { return (__arm_ctype[__c] & __ARM_CT_U); }
N#else
N    #define isupper(c) (__arm_ctype[c] & __ARM_CT_U)
N    extern int (isupper)(int /*c*/);
N#endif
N    /* non-0 iff c is an upper-case letter */
N
N/* isxdigit must test for the presence of __ARM_CT_N or __ARM_CT_X but not both. */
N/* This helper function avoids needing to evaluate c twice. */
N
N_ARMABI_INLINE_DEF int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
Xstatic inline int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
N#ifdef __cplusplus
S    inline int isxdigit(int __c){return __isxdigit_helper(__arm_ctype[__c]) & __ARM_CT_X;}
N#else
N    #define isxdigit(c) (__isxdigit_helper(__arm_ctype[c]) & __ARM_CT_X)
N    extern int (isxdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a digit, in 'a'..'f', or in 'A'..'F' */
N
N#endif /* __AEABI_PORTABILITY_LEVEL */
N
Nextern int tolower(int /*c*/);
N    /* if c is an upper-case letter then return the corresponding */
N    /* lower-case letter, otherwise return c.                     */
N
Nextern int toupper(int /*c*/);
N    /* if c is an lower-case letter then return the corresponding */
N    /* upper-case letter, otherwise return c.                     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __CTYPE_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __CTYPE_NO_EXPORTS
S      using ::std::isalnum;
S      using ::std::isalpha;
S      using ::std::iscntrl;
S      using ::std::isdigit;
S      using ::std::isblank;
S      using ::std::isgraph;
S      using ::std::islower;
S      using ::std::isprint;
S      using ::std::ispunct;
S      using ::std::isspace;
S      using ::std::isupper;
S      using ::std::isxdigit;
S      using ::std::tolower;
S      using ::std::toupper;
S    #endif /* __CTYPE_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of ctype.h */
N
L 33 "..\..\..\Library\support\common.h" 2
N
N#define TARGET_RT_LITTLE_ENDIAN
N
N#ifdef __GNUC__
S#define WEAK __attribute__ ((weak))
S#define USED __attribute__ ((used))
S#elif defined ( __ICCARM__ )
X#elif 0L
S#define WEAK __weak
S#define USED 
N#elif defined ( __CC_ARM ) //KEIL
X#elif 1L 
N#define WEAK __attribute__ ((weak))
N#define USED __attribute__ ((used))
N#endif 
N
N// ==== COMPATIBILITY TYPES
Ntypedef uint8_t         Boolean;
N
N#if( !defined( INT_MAX ) )
X#if( !0L )
N    #define INT_MAX     2147483647
N#endif
N
N#ifndef ssize_t
N#define ssize_t int
N#endif
N
N// ==== OSStatus ====
Ntypedef int32_t         OSStatus;
N
N#define kNoErr                      0       //! No error occurred.
N#define kGeneralErr                -1       //! General error.
N#define kInProgressErr              1       //! Operation in progress.
N
N// Generic error codes are in the range -6700 to -6779.
N
N#define kGenericErrorBase           -6700   //! Starting error code for all generic errors.
N
N#define kUnknownErr                 -6700   //! Unknown error occurred.
N#define kOptionErr                  -6701   //! Option was not acceptable.
N#define kSelectorErr                -6702   //! Selector passed in is invalid or unknown.
N#define kExecutionStateErr          -6703   //! Call made in the wrong execution state (e.g. called at interrupt time).
N#define kPathErr                    -6704   //! Path is invalid, too long, or otherwise not usable.
N#define kParamErr                   -6705   //! Parameter is incorrect, missing, or not appropriate.
N#define kUserRequiredErr            -6706   //! User interaction is required.
N#define kCommandErr                 -6707   //! Command invalid or not supported.
N#define kIDErr                      -6708   //! Unknown, invalid, or inappropriate identifier.
N#define kStateErr                   -6709   //! Not in appropriate state to perform operation.
N#define kRangeErr                   -6710   //! Index is out of range or not valid.
N#define kRequestErr                 -6711   //! Request was improperly formed or not appropriate.
N#define kResponseErr                -6712   //! Response was incorrect or out of sequence.
N#define kChecksumErr                -6713   //! Checksum does not match the actual data.
N#define kNotHandledErr              -6714   //! Operation was not handled (or not handled completely).
N#define kVersionErr                 -6715   //! Version is not correct or not compatible.
N#define kSignatureErr               -6716   //! Signature did not match what was expected.
N#define kFormatErr                  -6717   //! Unknown, invalid, or inappropriate file/data format.
N#define kNotInitializedErr          -6718   //! Action request before needed services were initialized.
N#define kAlreadyInitializedErr      -6719   //! Attempt made to initialize when already initialized.
N#define kNotInUseErr                -6720   //! Object not in use (e.g. cannot abort if not already in use).
N#define kAlreadyInUseErr            -6721   //! Object is in use (e.g. cannot reuse active param blocks).
N#define kTimeoutErr                 -6722   //! Timeout occurred.
N#define kCanceledErr                -6723   //! Operation canceled (successful cancel).
N#define kAlreadyCanceledErr         -6724   //! Operation has already been canceled.
N#define kCannotCancelErr            -6725   //! Operation could not be canceled (maybe already done or invalid).
N#define kDeletedErr                 -6726   //! Object has already been deleted.
N#define kNotFoundErr                -6727   //! Something was not found.
N#define kNoMemoryErr                -6728   //! Not enough memory was available to perform the operation.
N#define kNoResourcesErr             -6729   //! Resources unavailable to perform the operation.
N#define kDuplicateErr               -6730   //! Duplicate found or something is a duplicate.
N#define kImmutableErr               -6731   //! Entity is not changeable.
N#define kUnsupportedDataErr         -6732   //! Data is unknown or not supported.
N#define kIntegrityErr               -6733   //! Data is corrupt.
N#define kIncompatibleErr            -6734   //! Data is not compatible or it is in an incompatible format.
N#define kUnsupportedErr             -6735   //! Feature or option is not supported.
N#define kUnexpectedErr              -6736   //! Error occurred that was not expected.
N#define kValueErr                   -6737   //! Value is not appropriate.
N#define kNotReadableErr             -6738   //! Could not read or reading is not allowed.
N#define kNotWritableErr             -6739   //! Could not write or writing is not allowed.
N#define kBadReferenceErr            -6740   //! An invalid or inappropriate reference was specified.
N#define kFlagErr                    -6741   //! An invalid, inappropriate, or unsupported flag was specified.
N#define kMalformedErr               -6742   //! Something was not formed correctly.
N#define kSizeErr                    -6743   //! Size was too big, too small, or not appropriate.
N#define kNameErr                    -6744   //! Name was not correct, allowed, or appropriate.
N#define kNotPreparedErr             -6745   //! Device or service is not ready.
N#define kReadErr                    -6746   //! Could not read.
N#define kWriteErr                   -6747   //! Could not write.
N#define kMismatchErr                -6748   //! Something does not match.
N#define kDateErr                    -6749   //! Date is invalid or out-of-range.
N#define kUnderrunErr                -6750   //! Less data than expected.
N#define kOverrunErr                 -6751   //! More data than expected.
N#define kEndingErr                  -6752   //! Connection, session, or something is ending.
N#define kConnectionErr              -6753   //! Connection failed or could not be established.
N#define kAuthenticationErr          -6754   //! Authentication failed or is not supported.
N#define kOpenErr                    -6755   //! Could not open file, pipe, device, etc.
N#define kTypeErr                    -6756   //! Incorrect or incompatible type (e.g. file, data, etc.).
N#define kSkipErr                    -6757   //! Items should be or was skipped.
N#define kNoAckErr                   -6758   //! No acknowledge.
N#define kCollisionErr               -6759   //! Collision occurred (e.g. two on bus at same time).
N#define kBackoffErr                 -6760   //! Backoff in progress and operation intentionally failed.
N#define kNoAddressAckErr            -6761   //! No acknowledge of address.
N#define kInternalErr                -6762   //! An error internal to the implementation occurred.
N#define kNoSpaceErr                 -6763   //! Not enough space to perform operation.
N#define kCountErr                   -6764   //! Count is incorrect.
N#define kEndOfDataErr               -6765   //! Reached the end of the data (e.g. recv returned 0).
N#define kWouldBlockErr              -6766   //! Would need to block to continue (e.g. non-blocking read/write).
N#define kLookErr                    -6767   //! Special case that needs to be looked at (e.g. interleaved data).
N#define kSecurityRequiredErr        -6768   //! Security is required for the operation (e.g. must use encryption).
N#define kOrderErr                   -6769   //! Order is incorrect.
N#define kUpgradeErr                 -6770   //! Must upgrade.
N#define kAsyncNoErr                 -6771   //! Async operation successfully started and is now in progress.
N#define kDeprecatedErr              -6772   //! Operation or data is deprecated.
N#define kPermissionErr              -6773   //! Permission denied.
N
N#define kGenericErrorEnd            -6779   //! Last generic error code (inclusive)
N
N
N//MXCHIP added for module
N#define EWOULDBLOCK 35      /* Operation would block */
N
N
N// ==== C TYPE SAFE MACROS ====
N//---------------------------------------------------------------------------------------------------------------------------
N/*! @group      ctype safe macros
N    @abstract   Wrappers for the ctype.h macros make them safe when used with signed characters.
N    @discussion
N
N    Some implementations of the ctype.h macros use the character value to directly index into a table.
N    This can lead to crashes and other problems when used with signed characters if the character value
N    is greater than 127 because the values 128-255 will appear to be negative if viewed as a signed char.
N    A negative subscript to an array causes it to index before the beginning and access invalid memory.
N
N    To work around this, these *_safe wrappers mask the value and cast it to an unsigned char.
N*/
N
N#define isalnum_safe( X )       isalnum(  ( (unsigned char)( ( X ) & 0xFF ) ) )
N#define isalpha_safe( X )       isalpha(  ( (unsigned char)( ( X ) & 0xFF ) ) )
N#define iscntrl_safe( X )       iscntrl(  ( (unsigned char)( ( X ) & 0xFF ) ) )
N#define isdigit_safe( X )       isdigit(  ( (unsigned char)( ( X ) & 0xFF ) ) )
N#define isgraph_safe( X )       isgraph(  ( (unsigned char)( ( X ) & 0xFF ) ) )
N#define islower_safe( X )       islower(  ( (unsigned char)( ( X ) & 0xFF ) ) )
N#define isoctal_safe( X )       isoctal(  ( (unsigned char)( ( X ) & 0xFF ) ) )
N#define isprint_safe( X )       isprint(  ( (unsigned char)( ( X ) & 0xFF ) ) )
N#define ispunct_safe( X )       ispunct(  ( (unsigned char)( ( X ) & 0xFF ) ) )
N#define isspace_safe( X )       isspace(  ( (unsigned char)( ( X ) & 0xFF ) ) )
N#define isupper_safe( X )       isupper(  ( (unsigned char)( ( X ) & 0xFF ) ) )
N#define isxdigit_safe( X )      isxdigit( ( (unsigned char)( ( X ) & 0xFF ) ) )
N#define tolower_safe( X )       tolower(  ( (unsigned char)( ( X ) & 0xFF ) ) )
N#define toupper_safe( X )       toupper(  ( (unsigned char)( ( X ) & 0xFF ) ) )
N
N
N// ==== SHA DEFINES ====
N#define SHA_DIGEST_LENGTH                   20
N#define SHA_CTX                             SHA1Context
N#define SHA1_Init( CTX )                    SHA1Reset( (CTX) )
N#define SHA1_Update( CTX, PTR, LEN )        SHA1Input( (CTX), (PTR), (LEN) )
N#define SHA1_Final( DIGEST, CTX )           SHA1Result( (CTX), (DIGEST) )
N#define SHA1( PTR, LEN, DIGEST )            SHA1Direct( (PTR), (LEN), (DIGEST) )
N
N#define SHA512_DIGEST_LENGTH                64
N#define SHA512_CTX                          SHA512Context
N#define SHA512_Init( CTX )                  SHA512Reset( (CTX) )
N#define SHA512_Update( CTX, PTR, LEN )      SHA512Input( (CTX), (PTR), (LEN) )
N#define SHA512_Final( DIGEST, CTX )         SHA512Result( (CTX), (DIGEST) )
N#define SHA512( PTR, LEN, DIGEST )          SHA512Direct( (PTR), (LEN), (DIGEST) )
N
N#define SHA3_DIGEST_LENGTH                  64
N#define SHA3_CTX                            SHA3_CTX_compat
N#define SHA3_Init( CTX )                    SHA3_Init_compat( (CTX) )
N#define SHA3_Update( CTX, PTR, LEN )        SHA3_Update_compat( (CTX), (PTR), (LEN) )
N#define SHA3_Final( DIGEST, CTX )           SHA3_Final_compat( (DIGEST), (CTX) )
N#define SHA3( PTR, LEN, DIGEST )            SHA3_compat( (PTR), (LEN), DIGEST )
N
N
N// ==== MIN / MAX ====
N//---------------------------------------------------------------------------------------------------------------------------
N/*! @function   Min
N    @abstract   Returns the lesser of X and Y.
N*/
N#if( !defined( Min ) )
X#if( !0L )
N    #define Min( X, Y )     ( ( ( X ) < ( Y ) ) ? ( X ) : ( Y ) )
N#endif
N
N//---------------------------------------------------------------------------------------------------------------------------
N/*! @function   Max
N    @abstract   Returns the greater of X and Y.
N*/
N#if( !defined( Max ) )
X#if( !0L )
N    #define Max( X, Y )     ( ( ( X ) > ( Y ) ) ? ( X ) : ( Y ) )
N#endif
N
N
N// ==== Alignment / Endian safe read/write/swap macros ====
N#define ReadBig16( PTR ) \
N    ( (uint16_t)( \
N        ( ( (uint16_t)( (uint8_t *)(PTR) )[ 0 ] ) << 8 ) | \
N          ( (uint16_t)( (uint8_t *)(PTR) )[ 1 ] ) ) )
X#define ReadBig16( PTR )     ( (uint16_t)(         ( ( (uint16_t)( (uint8_t *)(PTR) )[ 0 ] ) << 8 ) |           ( (uint16_t)( (uint8_t *)(PTR) )[ 1 ] ) ) )
N
N#define ReadBig32( PTR ) \
N    ( (uint32_t)( \
N        ( ( (uint32_t)( (uint8_t *)(PTR) )[ 0 ] ) << 24 ) | \
N        ( ( (uint32_t)( (uint8_t *)(PTR) )[ 1 ] ) << 16 ) | \
N        ( ( (uint32_t)( (uint8_t *)(PTR) )[ 2 ] ) <<  8 ) | \
N          ( (uint32_t)( (uint8_t *)(PTR) )[ 3 ] ) ) )
X#define ReadBig32( PTR )     ( (uint32_t)(         ( ( (uint32_t)( (uint8_t *)(PTR) )[ 0 ] ) << 24 ) |         ( ( (uint32_t)( (uint8_t *)(PTR) )[ 1 ] ) << 16 ) |         ( ( (uint32_t)( (uint8_t *)(PTR) )[ 2 ] ) <<  8 ) |           ( (uint32_t)( (uint8_t *)(PTR) )[ 3 ] ) ) )
N
N#define ReadBig48( PTR ) \
N    ( (uint64_t)( \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 0 ] ) << 40 ) | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 1 ] ) << 32 ) | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 2 ] ) << 24 ) | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 3 ] ) << 16 ) | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 4 ] ) <<  8 ) | \
N          ( (uint64_t)( (uint8_t *)(PTR) )[ 5 ] ) ) )
X#define ReadBig48( PTR )     ( (uint64_t)(         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 0 ] ) << 40 ) |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 1 ] ) << 32 ) |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 2 ] ) << 24 ) |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 3 ] ) << 16 ) |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 4 ] ) <<  8 ) |           ( (uint64_t)( (uint8_t *)(PTR) )[ 5 ] ) ) )
N
N#define ReadBig64( PTR ) \
N    ( (uint64_t)( \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 0 ] ) << 56 ) | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 1 ] ) << 48 ) | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 2 ] ) << 40 ) | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 3 ] ) << 32 ) | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 4 ] ) << 24 ) | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 5 ] ) << 16 ) | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 6 ] ) <<  8 ) | \
N          ( (uint64_t)( (uint8_t *)(PTR) )[ 7 ] ) ) )
X#define ReadBig64( PTR )     ( (uint64_t)(         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 0 ] ) << 56 ) |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 1 ] ) << 48 ) |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 2 ] ) << 40 ) |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 3 ] ) << 32 ) |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 4 ] ) << 24 ) |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 5 ] ) << 16 ) |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 6 ] ) <<  8 ) |           ( (uint64_t)( (uint8_t *)(PTR) )[ 7 ] ) ) )
N
N// Big endian Writing
N#define WriteBig16( PTR, X ) \
N    do \
N    { \
N        ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)(   (X)         & 0xFF ); \
N    \
N    }   while( 0 )
X#define WriteBig16( PTR, X )     do     {         ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)(   (X)         & 0xFF );         }   while( 0 )
N
N#define WriteBig32( PTR, X ) \
N    do \
N    { \
N        ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)( ( (X) >> 24 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)( ( (X) >> 16 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 2 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 3 ] = (uint8_t)(   (X)         & 0xFF ); \
N    \
N    }   while( 0 )
X#define WriteBig32( PTR, X )     do     {         ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)( ( (X) >> 24 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)( ( (X) >> 16 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 2 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 3 ] = (uint8_t)(   (X)         & 0xFF );         }   while( 0 )
N
N#define WriteBig48( PTR, X ) \
N    do \
N    { \
N        ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)( ( (X) >> 40 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)( ( (X) >> 32 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 2 ] = (uint8_t)( ( (X) >> 24 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 3 ] = (uint8_t)( ( (X) >> 16 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 4 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 5 ] = (uint8_t)(   (X)         & 0xFF ); \
N    \
N    }   while( 0 )
X#define WriteBig48( PTR, X )     do     {         ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)( ( (X) >> 40 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)( ( (X) >> 32 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 2 ] = (uint8_t)( ( (X) >> 24 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 3 ] = (uint8_t)( ( (X) >> 16 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 4 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 5 ] = (uint8_t)(   (X)         & 0xFF );         }   while( 0 )
N
N#define WriteBig64( PTR, X ) \
N    do \
N    { \
N        ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)( ( (X) >> 56 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)( ( (X) >> 48 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 2 ] = (uint8_t)( ( (X) >> 40 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 3 ] = (uint8_t)( ( (X) >> 32 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 4 ] = (uint8_t)( ( (X) >> 24 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 5 ] = (uint8_t)( ( (X) >> 16 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 6 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 7 ] = (uint8_t)(   (X)         & 0xFF ); \
N    \
N    }   while( 0 )
X#define WriteBig64( PTR, X )     do     {         ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)( ( (X) >> 56 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)( ( (X) >> 48 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 2 ] = (uint8_t)( ( (X) >> 40 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 3 ] = (uint8_t)( ( (X) >> 32 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 4 ] = (uint8_t)( ( (X) >> 24 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 5 ] = (uint8_t)( ( (X) >> 16 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 6 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 7 ] = (uint8_t)(   (X)         & 0xFF );         }   while( 0 )
N
N// Little endian reading
N#define ReadLittle16( PTR ) \
N    ( (uint16_t)( \
N          ( (uint16_t)( (uint8_t *)(PTR) )[ 0 ] ) | \
N        ( ( (uint16_t)( (uint8_t *)(PTR) )[ 1 ] ) <<  8 ) ) )
X#define ReadLittle16( PTR )     ( (uint16_t)(           ( (uint16_t)( (uint8_t *)(PTR) )[ 0 ] ) |         ( ( (uint16_t)( (uint8_t *)(PTR) )[ 1 ] ) <<  8 ) ) )
N
N#define ReadLittle32( PTR ) \
N    ( (uint32_t)( \
N          ( (uint32_t)( (uint8_t *)(PTR) )[ 0 ] ) | \
N        ( ( (uint32_t)( (uint8_t *)(PTR) )[ 1 ] ) <<  8 ) | \
N        ( ( (uint32_t)( (uint8_t *)(PTR) )[ 2 ] ) << 16 ) | \
N        ( ( (uint32_t)( (uint8_t *)(PTR) )[ 3 ] ) << 24 ) ) )
X#define ReadLittle32( PTR )     ( (uint32_t)(           ( (uint32_t)( (uint8_t *)(PTR) )[ 0 ] ) |         ( ( (uint32_t)( (uint8_t *)(PTR) )[ 1 ] ) <<  8 ) |         ( ( (uint32_t)( (uint8_t *)(PTR) )[ 2 ] ) << 16 ) |         ( ( (uint32_t)( (uint8_t *)(PTR) )[ 3 ] ) << 24 ) ) )
N
N#define ReadLittle48( PTR ) \
N    ( (uint64_t)( \
N          ( (uint64_t)( (uint8_t *)(PTR) )[ 0 ] )           | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 1 ] ) <<  8 )   | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 2 ] ) << 16 )   | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 3 ] ) << 24 )   | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 4 ] ) << 32 )   | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 5 ] ) << 40 ) ) )
X#define ReadLittle48( PTR )     ( (uint64_t)(           ( (uint64_t)( (uint8_t *)(PTR) )[ 0 ] )           |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 1 ] ) <<  8 )   |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 2 ] ) << 16 )   |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 3 ] ) << 24 )   |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 4 ] ) << 32 )   |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 5 ] ) << 40 ) ) )
N
N#define ReadLittle64( PTR ) \
N    ( (uint64_t)( \
N          ( (uint64_t)( (uint8_t *)(PTR) )[ 0 ] )           | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 1 ] ) <<  8 )   | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 2 ] ) << 16 )   | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 3 ] ) << 24 )   | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 4 ] ) << 32 )   | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 5 ] ) << 40 )   | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 6 ] ) << 48 )   | \
N        ( ( (uint64_t)( (uint8_t *)(PTR) )[ 7 ] ) << 56 ) ) )
X#define ReadLittle64( PTR )     ( (uint64_t)(           ( (uint64_t)( (uint8_t *)(PTR) )[ 0 ] )           |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 1 ] ) <<  8 )   |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 2 ] ) << 16 )   |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 3 ] ) << 24 )   |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 4 ] ) << 32 )   |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 5 ] ) << 40 )   |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 6 ] ) << 48 )   |         ( ( (uint64_t)( (uint8_t *)(PTR) )[ 7 ] ) << 56 ) ) )
N
N// Little endian writing
N#define WriteLittle16( PTR, X ) \
N    do \
N    { \
N        ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)(   (X)         & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF ); \
N    \
N    }   while( 0 )
X#define WriteLittle16( PTR, X )     do     {         ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)(   (X)         & 0xFF );         ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF );         }   while( 0 )
N
N#define WriteLittle32( PTR, X ) \
N    do \
N    { \
N        ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)(   (X)         & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 2 ] = (uint8_t)( ( (X) >> 16 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 3 ] = (uint8_t)( ( (X) >> 24 ) & 0xFF ); \
N    \
N    }   while( 0 )
X#define WriteLittle32( PTR, X )     do     {         ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)(   (X)         & 0xFF );         ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 2 ] = (uint8_t)( ( (X) >> 16 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 3 ] = (uint8_t)( ( (X) >> 24 ) & 0xFF );         }   while( 0 )
N
N#define WriteLittle48( PTR, X ) \
N    do \
N    { \
N        ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)(   (X)         & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 2 ] = (uint8_t)( ( (X) >> 16 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 3 ] = (uint8_t)( ( (X) >> 24 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 4 ] = (uint8_t)( ( (X) >> 32 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 5 ] = (uint8_t)( ( (X) >> 40 ) & 0xFF ); \
N    \
N    }   while( 0 )
X#define WriteLittle48( PTR, X )     do     {         ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)(   (X)         & 0xFF );         ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 2 ] = (uint8_t)( ( (X) >> 16 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 3 ] = (uint8_t)( ( (X) >> 24 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 4 ] = (uint8_t)( ( (X) >> 32 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 5 ] = (uint8_t)( ( (X) >> 40 ) & 0xFF );         }   while( 0 )
N
N#define WriteLittle64( PTR, X ) \
N    do \
N    { \
N        ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)(   (X)         & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 2 ] = (uint8_t)( ( (X) >> 16 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 3 ] = (uint8_t)( ( (X) >> 24 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 4 ] = (uint8_t)( ( (X) >> 32 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 5 ] = (uint8_t)( ( (X) >> 40 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 6 ] = (uint8_t)( ( (X) >> 48 ) & 0xFF ); \
N        ( (uint8_t *)(PTR) )[ 7 ] = (uint8_t)( ( (X) >> 56 ) & 0xFF ); \
N    \
N    }   while( 0 )
X#define WriteLittle64( PTR, X )     do     {         ( (uint8_t *)(PTR) )[ 0 ] = (uint8_t)(   (X)         & 0xFF );         ( (uint8_t *)(PTR) )[ 1 ] = (uint8_t)( ( (X) >>  8 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 2 ] = (uint8_t)( ( (X) >> 16 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 3 ] = (uint8_t)( ( (X) >> 24 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 4 ] = (uint8_t)( ( (X) >> 32 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 5 ] = (uint8_t)( ( (X) >> 40 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 6 ] = (uint8_t)( ( (X) >> 48 ) & 0xFF );         ( (uint8_t *)(PTR) )[ 7 ] = (uint8_t)( ( (X) >> 56 ) & 0xFF );         }   while( 0 )
N
N
N#if( !defined( TARGET_RT_LITTLE_ENDIAN ) && !defined( TARGET_RT_BIG_ENDIAN ) )
X#if( !1L && !0L )
S    #error unknown byte order - update your Makefile to define the target platform endianness as TARGET_RT_BIG_ENDIAN / TARGET_RT_LITTLE_ENDIAN
N#endif
N
N#if( TARGET_RT_BIG_ENDIAN )
S    #define ReadHost16( PTR )           ReadBig16( (PTR) )
S    #define ReadHost32( PTR )           ReadBig32( (PTR) )
S    #define ReadHost48( PTR )           ReadBig48( (PTR) )
S    #define ReadHost64( PTR )           ReadBig64( (PTR) )
S
S    #define WriteHost16( PTR, X )       WriteBig16( (PTR), (X) )
S    #define WriteHost32( PTR, X )       WriteBig32( (PTR), (X) )
S    #define WriteHost48( PTR, X )       WriteBig48( (PTR), (X) )
S    #define WriteHost64( PTR, X )       WriteBig64( (PTR), (X) )
N#else
N    #define ReadHost16( PTR )           ReadLittle16( (PTR) )
N    #define ReadHost32( PTR )           ReadLittle32( (PTR) )
N    #define ReadHost48( PTR )           ReadLittle48( (PTR) )
N    #define ReadHost64( PTR )           ReadLittle64( (PTR) )
N
N    #define WriteHost16( PTR, X )       WriteLittle16( (PTR), (X) )
N    #define WriteHost32( PTR, X )       WriteLittle32( (PTR), (X) )
N    #define WriteHost48( PTR, X )       WriteLittle48( (PTR), (X) )
N    #define WriteHost64( PTR, X )       WriteLittle64( (PTR), (X) )
N#endif
N
N// Unconditional swap read/write.
N#if( TARGET_RT_BIG_ENDIAN )
S    #define ReadSwap16( PTR )           ReadLittle16( (PTR) )
S    #define ReadSwap32( PTR )           ReadLittle32( (PTR) )
S    #define ReadSwap48( PTR )           ReadLittle48( (PTR) )
S    #define ReadSwap64( PTR )           ReadLittle64( (PTR) )
S
S    #define WriteSwap16( PTR, X )       WriteLittle16( (PTR), (X) )
S    #define WriteSwap32( PTR, X )       WriteLittle32( (PTR), (X) )
S    #define WriteSwap48( PTR, X )       WriteLittle48( (PTR), (X) )
S    #define WriteSwap64( PTR, X )       WriteLittle64( (PTR), (X) )
N#else
N    #define ReadSwap16( PTR )           ReadBig16( (PTR) )
N    #define ReadSwap32( PTR )           ReadBig32( (PTR) )
N    #define ReadSwap48( PTR )           ReadBig48( (PTR) )
N    #define ReadSwap64( PTR )           ReadBig64( (PTR) )
N
N    #define WriteSwap16( PTR, X )       WriteBig16( (PTR), (X) )
N    #define WriteSwap32( PTR, X )       WriteBig32( (PTR), (X) )
N    #define WriteSwap48( PTR, X )       WriteBig48( (PTR), (X) )
N    #define WriteSwap64( PTR, X )       WriteBig64( (PTR), (X) )
N#endif
N
N// Memory swaps
N#if( TARGET_RT_BIG_ENDIAN )
S    #define HostToBig16Mem( SRC, LEN, DST )         do {} while( 0 )
S    #define BigToHost16Mem( SRC, LEN, DST )         do {} while( 0 )
S
S    #define LittleToHost16Mem( SRC, LEN, DST )      Swap16Mem( (SRC), (LEN), (DST) )
S    #define LittleToHost16Mem( SRC, LEN, DST )      Swap16Mem( (SRC), (LEN), (DST) )
N#else
N    #define HostToBig16Mem( SRC, LEN, DST )         Swap16Mem( (SRC), (LEN), (DST) )
N    #define BigToHost16Mem( SRC, LEN, DST )         Swap16Mem( (SRC), (LEN), (DST) )
N
N    #define HostToLittle16Mem( SRC, LEN, DST )      do {} while( 0 )
N    #define LittleToHost16Mem( SRC, LEN, DST )      do {} while( 0 )
N#endif
N
N// Unconditional endian swaps
N#define Swap16( X ) \
N    ( (uint16_t)( \
N        ( ( ( (uint16_t)(X) ) << 8 ) & UINT16_C( 0xFF00 ) ) | \
N        ( ( ( (uint16_t)(X) ) >> 8 ) & UINT16_C( 0x00FF ) ) ) )
X#define Swap16( X )     ( (uint16_t)(         ( ( ( (uint16_t)(X) ) << 8 ) & UINT16_C( 0xFF00 ) ) |         ( ( ( (uint16_t)(X) ) >> 8 ) & UINT16_C( 0x00FF ) ) ) )
N
N#define Swap32( X ) \
N    ( (uint32_t)( \
N        ( ( ( (uint32_t)(X) ) << 24 ) & UINT32_C( 0xFF000000 ) ) | \
N        ( ( ( (uint32_t)(X) ) <<  8 ) & UINT32_C( 0x00FF0000 ) ) | \
N        ( ( ( (uint32_t)(X) ) >>  8 ) & UINT32_C( 0x0000FF00 ) ) | \
N        ( ( ( (uint32_t)(X) ) >> 24 ) & UINT32_C( 0x000000FF ) ) ) )
X#define Swap32( X )     ( (uint32_t)(         ( ( ( (uint32_t)(X) ) << 24 ) & UINT32_C( 0xFF000000 ) ) |         ( ( ( (uint32_t)(X) ) <<  8 ) & UINT32_C( 0x00FF0000 ) ) |         ( ( ( (uint32_t)(X) ) >>  8 ) & UINT32_C( 0x0000FF00 ) ) |         ( ( ( (uint32_t)(X) ) >> 24 ) & UINT32_C( 0x000000FF ) ) ) )
N
N#define Swap64( X ) \
N    ( (uint64_t)( \
N        ( ( ( (uint64_t)(X) ) << 56 ) & UINT64_C( 0xFF00000000000000 ) ) | \
N        ( ( ( (uint64_t)(X) ) << 40 ) & UINT64_C( 0x00FF000000000000 ) ) | \
N        ( ( ( (uint64_t)(X) ) << 24 ) & UINT64_C( 0x0000FF0000000000 ) ) | \
N        ( ( ( (uint64_t)(X) ) <<  8 ) & UINT64_C( 0x000000FF00000000 ) ) | \
N        ( ( ( (uint64_t)(X) ) >>  8 ) & UINT64_C( 0x00000000FF000000 ) ) | \
N        ( ( ( (uint64_t)(X) ) >> 24 ) & UINT64_C( 0x0000000000FF0000 ) ) | \
N        ( ( ( (uint64_t)(X) ) >> 40 ) & UINT64_C( 0x000000000000FF00 ) ) | \
N        ( ( ( (uint64_t)(X) ) >> 56 ) & UINT64_C( 0x00000000000000FF ) ) ) )
X#define Swap64( X )     ( (uint64_t)(         ( ( ( (uint64_t)(X) ) << 56 ) & UINT64_C( 0xFF00000000000000 ) ) |         ( ( ( (uint64_t)(X) ) << 40 ) & UINT64_C( 0x00FF000000000000 ) ) |         ( ( ( (uint64_t)(X) ) << 24 ) & UINT64_C( 0x0000FF0000000000 ) ) |         ( ( ( (uint64_t)(X) ) <<  8 ) & UINT64_C( 0x000000FF00000000 ) ) |         ( ( ( (uint64_t)(X) ) >>  8 ) & UINT64_C( 0x00000000FF000000 ) ) |         ( ( ( (uint64_t)(X) ) >> 24 ) & UINT64_C( 0x0000000000FF0000 ) ) |         ( ( ( (uint64_t)(X) ) >> 40 ) & UINT64_C( 0x000000000000FF00 ) ) |         ( ( ( (uint64_t)(X) ) >> 56 ) & UINT64_C( 0x00000000000000FF ) ) ) )
N
N// Host<->Network/Big endian swaps
N#if( TARGET_RT_BIG_ENDIAN )
S    #define hton16( X )     (X)
S    #define ntoh16( X )     (X)
S
S    #define hton32( X )     (X)
S    #define ntoh32( X )     (X)
S
S    #define hton64( X )     (X)
S    #define ntoh64( X )     (X)
N#else
N    #define hton16( X )     Swap16( X )
N    #define ntoh16( X )     Swap16( X )
N
N    #define hton32( X )     Swap32( X )
N    #define ntoh32( X )     Swap32( X )
N
N    #define hton64( X )     Swap64( X )
N    #define ntoh64( X )     Swap64( X )
N#endif
N
N    #define htons( X )      hton16( X )
N    #define ntohs( X )      ntoh16( X )
N
N    #define htonl( X )      hton32( X )
N    #define ntohl( X )      ntoh32( X )
N
N//---------------------------------------------------------------------------------------------------------------------------
N/*! @function   BitArray
N    @abstract   Macros for working with bit arrays.
N    @discussion
N
N    This treats bit numbers starting from the left so bit 0 is 0x80 in byte 0, bit 1 is 0x40 in bit 0,
N    bit 8 is 0x80 in byte 1, etc. For example, the following ASCII art shows how the bits are arranged:
N
N                                 1 1 1 1 1 1 1 1 1 1 2 2 2 2
N    Bit      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
N            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
N            |    x          |x              |  x           x| = 0x20 0x80 0x41 (bits 2, 8, 17, and 23).
N            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
N    Byte    0               1               2
N*/
N#define BitArray_MinBytes( ARRAY, N_BYTES )         memrlen( (ARRAY), (N_BYTES) )
N#define BitArray_MaxBytes( BITS )                   ( ( (BITS) + 7 ) / 8 )
N#define BitArray_MaxBits( ARRAY_BYTES )             ( (ARRAY_BYTES) * 8 )
N#define BitArray_Clear( ARRAY_PTR, ARRAY_BYTES )    memset( (ARRAY_PTR), 0, (ARRAY_BYTES) );
N#define BitArray_GetBit( PTR, LEN, BIT ) \
N    ( ( (BIT) < BitArray_MaxBits( (LEN) ) ) && ( (PTR)[ (BIT) / 8 ] & ( 1 << ( 7 - ( (BIT) & 7 ) ) ) ) )
X#define BitArray_GetBit( PTR, LEN, BIT )     ( ( (BIT) < BitArray_MaxBits( (LEN) ) ) && ( (PTR)[ (BIT) / 8 ] & ( 1 << ( 7 - ( (BIT) & 7 ) ) ) ) )
N#define BitArray_SetBit( ARRAY, BIT )               ( (ARRAY)[ (BIT) / 8 ] |=  ( 1 << ( 7 - ( (BIT) & 7 ) ) ) )
N#define BitArray_ClearBit( ARRAY, BIT )             ( (ARRAY)[ (BIT) / 8 ] &= ~( 1 << ( 7 - ( (BIT) & 7 ) ) ) )
N
N//---------------------------------------------------------------------------------------------------------------------------
N/*! @group      BitRotates
N    @abstract   Rotates X COUNT bits to the left or right.
N*/
N#define ROTL( X, N, SIZE )          ( ( (X) << (N) ) | ( (X) >> ( (SIZE) - N ) ) )
N#define ROTR( X, N, SIZE )          ( ( (X) >> (N) ) | ( (X) << ( (SIZE) - N ) ) )
N
N#define ROTL32( X, N )              ROTL( (X), (N), 32 )
N#define ROTR32( X, N )              ROTR( (X), (N), 32 )
N
N#define ROTL64( X, N )              ROTL( (X), (N), 64 )
N#define ROTR64( X, N )              ROTR( (X), (N), 64 )
N
N#define RotateBitsLeft( X, N )      ROTL( (X), (N), sizeof( (X) ) * 8 )
N#define RotateBitsRight( X, N )     ROTR( (X), (N), sizeof( (X) ) * 8 )
N
N// ==== Macros for minimum-width integer constants ====
N#if( !defined( INT8_C ) )
X#if( !1L )
S    #define INT8_C( value )         value
N#endif
N
N#if( !defined( INT16_C ) )
X#if( !1L )
S    #define INT16_C( value )        value
N#endif
N
N#if( !defined( INT32_C ) )
X#if( !1L )
S    #define INT32_C( value )        value
N#endif
N
N#define INT64_C_safe( value )       INT64_C( value )
N#if( !defined( INT64_C ) )
X#if( !1L )
S    #if( defined( _MSC_VER ) )
S        #define INT64_C( value )    value ## i64
S    #else
S        #define INT64_C( value )    value ## LL
S    #endif
N#endif
N
N#define UINT8_C_safe( value )       UINT8_C( value )
N#if( !defined( UINT8_C ) )
X#if( !1L )
S    #define UINT8_C( value )        value ## U
N#endif
N
N#define UINT16_C_safe( value )      UINT16_C( value )
N#if( !defined( UINT16_C ) )
X#if( !1L )
S    #define UINT16_C( value )       value ## U
N#endif
N
N#define UINT32_C_safe( value )      UINT32_C( value )
N#if( !defined( UINT32_C ) )
X#if( !1L )
S    #define UINT32_C( value )       value ## U
N#endif
N
N#define UINT64_C_safe( value )      UINT64_C( value )
N#if( !defined( UINT64_C ) )
X#if( !1L )
S    #if( defined( _MSC_VER ) )
S        #define UINT64_C( value )   value ## UI64
S    #else
S        #define UINT64_C( value )   value ## ULL
S    #endif
N#endif
N
N// ==== SOCKET MACROS ====
N#define IsValidSocket( X )                  ( ( X ) >= 0 )
N
N#ifndef __PTRDIFF_TYPE__
N#define __PTRDIFF_TYPE__ int
N#endif
N      
Ntypedef __PTRDIFF_TYPE__        ptrdiff_t;
Xtypedef int        ptrdiff_t;
N
N/* Suppress unused parameter warning */
N#ifndef UNUSED_PARAMETER
N#define UNUSED_PARAMETER(x) ( (void)(x) )
N#endif
N
N/* Suppress unused variable warning */
N#ifndef UNUSED_VARIABLE
N#define UNUSED_VARIABLE(x) ( (void)(x) )
N#endif
N
N/* Suppress unused variable warning occurring due to an assert which is disabled in release mode */
N#ifndef REFERENCE_DEBUG_ONLY_VARIABLE
N#define REFERENCE_DEBUG_ONLY_VARIABLE(x) ( (void)(x) )
N#endif
N
N
N#endif // __Common_h__
N
L 38 "..\..\..\include\MICOPlatform.h" 2
N
N#include "MicoDefaults.h"
L 1 "..\..\..\Bootloader\MicoDefaults.h" 1
N/**
N******************************************************************************
N* @file    MicoDefault.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    16-Sep-2014
N* @brief   This file provides the default configuration for MICO.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/
N
N#ifndef __MICODEFAULTS_H__
N#define __MICODEFAULTS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N#define NO_MICO_RTOS
N
N#ifdef __cplusplus
S} /*extern "C" */
N#endif
N
N#endif //__MICODEFAULTS_H__
L 40 "..\..\..\include\MICOPlatform.h" 2
N#include "platform.h" /* This file is unique for each platform */
L 1 "..\..\..\Platform\EMW3162\platform.h" 1
N/**
N******************************************************************************
N* @file    platform.h
N* @author  William Xu
N* @version V1.0.0
N* @date    05-May-2014
N* @brief   This file provides all MICO Peripherals defined for current platform.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N#include "platform_common_config.h"
L 1 "..\..\..\Platform\EMW3162\platform_common_config.h" 1
N/**
N******************************************************************************
N* @file    platform_common_config.h
N* @author  William Xu
N* @version V1.0.0
N* @date    05-May-2014
N* @brief   This file provides common configuration for current platform.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N#ifndef __PLATFORM_COMMON_CONFIG_H__
N#define __PLATFORM_COMMON_CONFIG_H__
N#pragma once
N
N/******************************************************
N*                      Macros
N******************************************************/
N
N/******************************************************
N*                    Constants
N******************************************************/
N
N/* MICO RTOS tick rate in Hz */
N#define MICO_DEFAULT_TICK_RATE_HZ                   (1000) 
N
N/************************************************************************
N * Uncomment to disable watchdog. For debugging only */
N//#define MICO_DISABLE_WATCHDOG
N
N/************************************************************************
N * Uncomment to disable standard IO, i.e. printf(), etc. */
N//#define MICO_DISABLE_STDIO
N
N/************************************************************************
N * Uncomment to disable MCU powersave API functions */
N//#define MICO_DISABLE_MCU_POWERSAVE
N
N/************************************************************************
N * Uncomment to enable MCU real time clock */
N#define MICO_ENABLE_MCU_RTC
N
N
N
N#define HSE_SOURCE              RCC_HSE_ON               /* Use external crystal                 */
N#define AHB_CLOCK_DIVIDER       RCC_SYSCLK_Div1          /* AHB clock = System clock             */
N#define APB1_CLOCK_DIVIDER      RCC_HCLK_Div4            /* APB1 clock = AHB clock / 4           */
N#define APB2_CLOCK_DIVIDER      RCC_HCLK_Div2            /* APB2 clock = AHB clock / 2           */
N#define PLL_SOURCE              RCC_PLLSource_HSE        /* PLL source = external crystal        */
N#define PLL_M_CONSTANT          26                       /* PLLM = 26                            */
N#define PLL_N_CONSTANT          240                      /* PLLN = 240                           */
N#define PLL_P_CONSTANT          2                        /* PLLP = 2                             */
N#define PPL_Q_CONSTANT          5                        /* PLLQ = 5                             */
N#define SYSTEM_CLOCK_SOURCE     RCC_SYSCLKSource_PLLCLK  /* System clock source = PLL clock      */
N#define SYSTICK_CLOCK_SOURCE    SysTick_CLKSource_HCLK   /* SysTick clock source = AHB clock     */
N#define INT_FLASH_WAIT_STATE    FLASH_Latency_3          /* Internal flash wait state = 3 cycles */
N
N#define SDIO_OOB_IRQ_BANK       GPIOB
N#define SDIO_CLK_BANK           GPIOC
N#define SDIO_CMD_BANK           GPIOD
N#define SDIO_D0_BANK            GPIOC
N#define SDIO_D1_BANK            GPIOC
N#define SDIO_D2_BANK            GPIOC
N#define SDIO_D3_BANK            GPIOC
N#define SDIO_OOB_IRQ_BANK_CLK   RCC_AHB1Periph_GPIOB
N#define SDIO_CLK_BANK_CLK       RCC_AHB1Periph_GPIOC
N#define SDIO_CMD_BANK_CLK       RCC_AHB1Periph_GPIOD
N#define SDIO_D0_BANK_CLK        RCC_AHB1Periph_GPIOC
N#define SDIO_D1_BANK_CLK        RCC_AHB1Periph_GPIOC
N#define SDIO_D2_BANK_CLK        RCC_AHB1Periph_GPIOC
N#define SDIO_D3_BANK_CLK        RCC_AHB1Periph_GPIOC
N#define SDIO_OOB_IRQ_PIN        13
N#define SDIO_CLK_PIN            12
N#define SDIO_CMD_PIN            2
N#define SDIO_D0_PIN             8
N#define SDIO_D1_PIN             9
N#define SDIO_D2_PIN             10
N#define SDIO_D3_PIN             11
N
N/* These are internal platform connections only */
Ntypedef enum
N{
N  MICO_GPIO_UNUSED = -1,
N  MICO_GPIO_WLAN_POWERSAVE_CLOCK = 0,
N  WL_GPIO0,
N  WL_GPIO1,
N  WL_REG,
N  WL_RESET,
N  MICO_SYS_LED,
N  MICO_RF_LED,
N  BOOT_SEL,
N  MFG_SEL,
N  EasyLink_BUTTON,
N  MICO_COMMON_GPIO_MAX,
N} mico_common_gpio_t;
N
N/* How the wlan's powersave clock is connected */
Ntypedef enum
N{
N  MICO_PWM_WLAN_POWERSAVE_CLOCK,
N  MICO_COMMON_PWM_MAX,
N} mico_common_pwm_t;
N
N/* WLAN Powersave Clock Source
N * The WLAN sleep clock can be driven from one of two sources:
N * 1. Timer/PWM (default)
N *    - With the PWM selected, the STM32 can *NOT* be put into MCU powersave mode or the PWM output will be disabled
N * 2. MCO (MCU Clock Output). 
N *    - Change the following directive to MICO_WLAN_POWERSAVE_CLOCK_IS_MCO
N */
N#define MICO_WLAN_POWERSAVE_CLOCK_SOURCE MICO_WLAN_POWERSAVE_CLOCK_IS_MCO
N
N#define MICO_WLAN_POWERSAVE_CLOCK_IS_NOT_EXIST  0
N#define MICO_WLAN_POWERSAVE_CLOCK_IS_PWM        1
N#define MICO_WLAN_POWERSAVE_CLOCK_IS_MCO        2
N
N#define WLAN_POWERSAVE_CLOCK_FREQUENCY 32768 /* 32768Hz        */
N#define WLAN_POWERSAVE_CLOCK_DUTY_CYCLE   50 /* 50% duty-cycle */
N
N#define WL_32K_OUT_BANK         GPIOA
N#define WL_32K_OUT_PIN          8
N#define WL_32K_OUT_BANK_CLK     RCC_AHB1Periph_GPIOA
N
N/* The number of UART interfaces this hardware platform has */
N#define NUMBER_OF_UART_INTERFACES  2
N
N#define UART_FOR_APP     MICO_UART_1
N#define STDIO_UART       MICO_UART_1
N#define MFG_TEST         MICO_UART_1
N#define CLI_UART         MICO_UART_1
N
N/* Define the address from where user application will be loaded.
NNote: the 1st sector 0x08000000-0x08003FFF is reserved for the IAP code */
N#define INTERNAL_FLASH_START_ADDRESS   (uint32_t)0x08000000
N#define INTERNAL_FLASH_END_ADDRESS     (uint32_t)0x080FFFFF
N#define INTERNAL_FLASH_SIZE            (INTERNAL_FLASH_END_ADDRESS - INTERNAL_FLASH_START_ADDRESS + 1)
N
N#define MICO_FLASH_FOR_APPLICATION  MICO_INTERNAL_FLASH
N#define APPLICATION_START_ADDRESS   (uint32_t)0x0800C000
N#define APPLICATION_END_ADDRESS     (uint32_t)0x0805FFFF
N#define APPLICATION_FLASH_SIZE      (APPLICATION_END_ADDRESS - APPLICATION_START_ADDRESS + 1)
N
N#define MICO_FLASH_FOR_UPDATE       MICO_INTERNAL_FLASH /* Optional */
N#define UPDATE_START_ADDRESS        (uint32_t)0x08060000  /* Optional */
N#define UPDATE_END_ADDRESS          (uint32_t)0x080BFFFF  /* Optional */
N#define UPDATE_FLASH_SIZE           (UPDATE_END_ADDRESS - UPDATE_START_ADDRESS + 1) /* 384k bytes, optional*/
N
N#define MICO_FLASH_FOR_BOOT         MICO_INTERNAL_FLASH
N#define BOOT_START_ADDRESS          (uint32_t)0x08000000 
N#define BOOT_END_ADDRESS            (uint32_t)0x08003FFF 
N#define BOOT_FLASH_SIZE             (BOOT_END_ADDRESS - BOOT_START_ADDRESS + 1)
N
N#define MICO_FLASH_FOR_DRIVER       MICO_INTERNAL_FLASH
N#define DRIVER_START_ADDRESS        (uint32_t)0x080C0000 
N#define DRIVER_END_ADDRESS          (uint32_t)0x080FFFFF 
N#define DRIVER_FLASH_SIZE           (DRIVER_END_ADDRESS - DRIVER_START_ADDRESS + 1)
N
N#define MICO_FLASH_FOR_PARA         MICO_INTERNAL_FLASH
N#define PARA_START_ADDRESS          (uint32_t)0x08004000 
N#define PARA_END_ADDRESS            (uint32_t)0x08007FFF
N#define PARA_FLASH_SIZE             (PARA_END_ADDRESS - PARA_START_ADDRESS + 1)  
N
N#define MICO_FLASH_FOR_EX_PARA      MICO_INTERNAL_FLASH
N#define EX_PARA_START_ADDRESS       (uint32_t)0x08008000 
N#define EX_PARA_END_ADDRESS         (uint32_t)0x0800BFFF
N#define EX_PARA_FLASH_SIZE          (EX_PARA_END_ADDRESS - EX_PARA_START_ADDRESS + 1)  
N
N/******************************************************
N*                   Enumerations
N******************************************************/
N
N/******************************************************
N*                 Type Definitions
N******************************************************/
N
N/******************************************************
N*                    Structures
N******************************************************/
N
N/******************************************************
N*                 Global Variables
N******************************************************/
N
N/******************************************************
N*               Function Declarations
N******************************************************/
N#endif
N
L 33 "..\..\..\Platform\EMW3162\platform.h" 2
N
N#pragma once
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/******************************************************
N *                      Macros
N ******************************************************/
N
N/******************************************************
N *                    Constants
N ******************************************************/
N  
N#define HARDWARE_REVISION   "3162"
N#define DEFAULT_NAME        "EMW3162 Module"
N#define MODEL               "EMW3162"
N
N   
N/******************************************************
N *                   Enumerations
N ******************************************************/
N
N/*
NEMW3162 on EMB-380-S platform pin definitions ...
N+-------------------------------------------------------------------------+
N| Enum ID       |Pin | STM32| Peripheral  |    Board     |   Peripheral   |
N|               | #  | Port | Available   |  Connection  |     Alias      |
N|---------------+----+------+-------------+--------------+----------------|
N| MICO_GPIO_1   | 1  | B  6 | GPIO        |              |                |
N|               |    |      | TIM4_CH1    |              |                |
N|               |    |      | CAN2_TX     |              |                |
N|               |    |      | USART1_TX   |              |                |
N|               |    |      | I2C1_SCL    |              | MICO_I2C1_SCL  |
N|               |    |      | CAN2_TX     |              |                |
N|---------------+----+------+-------------+--------------+----------------|
N| MICO_GPIO_2   | 2  | B  7 | GPIO        |              |                |
N|               |    |      | I2C1_SCL    |              | MICO_I2C1_SDA  |
N|               |    |      | USART1_RX   |              |                |
N|               |    |      | TIM4_CH2    |              |                |
N|---------------+----+------+-------------+--------------+----------------|
N|               | 3  | A  13| SWDIO       |              |                |
N|---------------+----+------+-------------+--------------+----------------|
N| MICO_GPIO_4   | 4  | C  7 | USART2_RX   |              | MICO_UART_2_RX |
N|               |    |      | GPIO        |              |                |
N|               |    |      | TIM8_CH2    |              |                |
N|               |    |      | TIM3_CH2    |              |                |
N|               |    |      | I2S3_MCK    |              |                |
N|---------------+----+------+-------------+--------------+----------------|
N| MICO_GPIO_5   | 5  | A  3 | ADC123_IN3  |              | MICO_ADC_1     |
N|               |    |      | GPIO        |              |                |
N|               |    |      | TIM2_CH4    |              |                |
N|               |    |      | TIM5_CH4    |              |                |
N|               |    |      | TIM9_CH2    |              |                |
N|               |    |      | UART2_RX    |              |                |
N|---------------+----+------+-------------+--------------+----------------|
N| MICO_GPIO_6   | 6  | A  4 | SPI1_NSS    |              | MICO_SPI_1_NSS |
N|               |    |      | GPIO        |              |                |
N|               |    |      | SPI3_NSS    |              |                |
N|               |    |      | I2S3_WS     |              |                |
N|---------------+----+------+-------------+--------------+----------------|
N| MICO_GPIO_7   | 7  | B  3 | JTDO        |              |                |
N|               |    |      | GPIO        |              |                |
N|               |    |      | I2S3_SCK    |              |                |
N|               |    |      | TIM2_CH2    |              |                |
N|               |    |      | SPI1_SCK    |              | MICO_SPI_1_SCK |
N|               |    |      | SPI3_SCK    |              |                |
N|---------------+----+------+-------------+--------------+----------------|
N| MICO_GPIO_8   | 8  | B  4 | NJRST       |              |                |
N|               |    |      | GPIO        |              |                |
N|               |    |      | SPI3_MISO   |              |                |
N|               |    |      | SPI1_MISO   |              | MICO_SPI_1_MISO|
N|               |    |      | TIM3_CH1    |              |                |
N|---------------+----+------+-------------+--------------+----------------|
N| MICO_GPIO_9   | 9  | B  5 | I2C1_SMBA   |              |                |
N|               |    |      | GPIO        |              |                |
N|               |    |      | CAN2_RX     |              |                |
N|               |    |      | SPI1_MOSI   |              |                |
N|               |    |      | SPI3_MOSI   |              | MICO_SPI_1_MOSI|
N|               |    |      | TIM3_CH2    |              |                |
N|---------------+----+------+-------------+--------------+----------------|
N| MICO_GPIO_10  | 10 | B  8 | GPIO        |              |                |
N|               |    |      | TIM4_CH3    |              | MICO_PWM_1     |
N|               |    |      | TIM10_CH1   |              |                |
N|               |    |      | I2C1_SCL    |              |                |
N|               |    |      | CAN1_RX     |              |                |
N|---------------+----+------+-------------+--------------+----------------|
N| MICO_GPIO_11  | 11 | A  1 | GPIO        |EasyLink_BUTTON |              |
N|               |    |      | TIM5_CH2    |              |                |
N|               |    |      | TIM2_CH2    |              |                |
N|               |    |      | ADC123_IN1  |              |                |
N|---------------+----+------+-------------+--------------+----------------|
N| MICO_GPIO_12  | 12 | C  2 | GPIO        |              |                |
N|               |    |      | ADC123_ IN12|              | MICO_ADC_2     |
N|---------------+----+------+-------------+--------------+----------------|
N| MICO_GPIO_13  | 13 | B 14 | GPIO        |              |                |
N|               |    |      | TIM1_CH2N   |              |                |
N|               |    |      | TIM12_CH1   |              | MICO_PWM_2     |
N|---------------+----+------+-------------+--------------+----------------|
N| MICO_GPIO_14  | 14 | C  6 | GPIO        |              |                |
N|               |    |      | TIM3_CH1    |              |                |
N|               |    |      | TIM8_CH1    |              |                |
N|               |    |      | USART6_TX   |              | MICO_UART_2_TX |
N|---------------+----+------+-------------+--------------+----------------|
N|               | 15 | GND  |             |              |                |
N|---------------+----+------+-------------+--------------+----------------|
N| MICO_GPIO_16  | 16 | B 1  | GPIO        |  RF_LED      |                |
N|               |    |      | TIM3_CH4    |              |                |
N|               |    |      | TIM8_CH3N   |              |                |
N|               |    |      | TIM1_CH4N   |              |                |
N|---------------+----+------+-------------+--------------+----------------|
N|               | 17 |nReset|             |              |                |
N|---------------+----+------+-------------+--------------+----------------|
N| MICO_GPIO_18  | 18 | A 15 | GPIO        |              |                |
N|               |    |      | JTDI        |              |                |
N+---------------+----+--------------------+--------------+----------------+
N| MICO_GPIO_19  | 19 | B 11 | GPIO        |              |                |
N|               |    |      | TIM2_CH4    |              | MICO_PWM_3     |
N+---------------+----+--------------------+--------------+----------------+
N| MICO_GPIO_20  | 20 | A 12 | GPIO        |              |                |
N|               |    |      | USART1_RTS  |              |                |
N|               |    |      | CAN1_TX     |              |                |
N|               |    |      | TIM1_ETR    |              |                |
N|               |    |      | OTG_FS_DP   |              |                |
N+---------------+----+--------------------+--------------+----------------+
N| MICO_GPIO_21  | 21 | A 11 | GPIO        |              |                |
N|               |    |      | USART1_CTS  |              |                |
N|               |    |      | CAN1_RX     |              |                |
N|               |    |      | TIM1_CH4    |              |                |
N|               |    |      | OTG_FS_DM   |              |                |
N+---------------+----+--------------------+--------------+----------------+
N| MICO_GPIO_22  | 22 | A  9 | GPIO        |              |                |
N|               |    |      | USART1_TX   |STDIO_UART_TX |                |
N|               |    |      | TIM1_CH2    |              |                |
N+---------------+----+--------------------+--------------+----------------+
N| MICO_GPIO_23  | 23 | A 10 | GPIO        |              |                |
N|               |    |      | USART1_RX   |STDIO_UART_RX |                |
N|               |    |      | TIM1_CH3    |              |                |
N|               |    |      | OTG_FS_ID   |              |                |
N+---------------+----+--------------------+--------------+----------------+
N|               | 24 | VCC  |             |              |                |
N+---------------+----+--------------------+--------------+----------------+
N|               | 25 | GND  |             |              |                |
N+---------------+----+--------------------+--------------+----------------+
N|               | 26 | NC   |             |              |                |
N+---------------+----+--------------------+--------------+----------------+
N|               | 27 | BOOT0|             |              |                |
N+---------------+----+--------------------+--------------+----------------+
N|               | 28 | A 14 | JTCK-SWCLK  |              |                |
N+---------------+----+--------------------+--------------+----------------+
N| MICO_GPIO_29  | 29 | A  0 | GPIO        |StandBy/WakeUp|                |
N|               |    |      | TIM2_CH1_ETR|              |                |
N|               |    |      | TIM5_CH1    |              |                |
N|               |    |      | TIM8_ETR    |              |                |
N+---------------+----+--------------------+--------------+----------------+
N| MICO_GPIO_30  | 30 | B  9 | GPIO        | Status_Sel   |                |
N|               |    |      | TIM4_CH4    |              |                |
N|               |    |      | TIM11_CH1   |              |                |
N|               |    |      | I2C1_SDA    |              |                |
N|               |    |      | CAN1_TX     |              |                |
N+---------------+----+--------------------+--------------+----------------+
N| MICO_SYS_LED  |    | B  0 | GPIO        |              |                |
N+---------------+----+--------------------+--------------+----------------+
N
NNotes
N1. These mappings are defined in <MICO-SDK>/Platform/BCM943362WCD4/platform.c
N2. STM32F2xx Datasheet  -> http://www.st.com/web/en/resource/technical/document/datasheet/CD00237391.pdf
N3. STM32F2xx Ref Manual -> http://www.st.com/web/en/resource/technical/document/reference_manual/CD00225773.pdf
N*/
N
N
Ntypedef enum
N{
N    MICO_GPIO_1 = MICO_COMMON_GPIO_MAX,
N    MICO_GPIO_2,
N    //MICO_GPIO_3,
N    MICO_GPIO_4,
N    MICO_GPIO_5,
N    MICO_GPIO_6,
N    MICO_GPIO_7,
N    MICO_GPIO_8,
N    MICO_GPIO_9,
N    MICO_GPIO_10,
N    //MICO_GPIO_11,
N    MICO_GPIO_12,
N    MICO_GPIO_13,
N    MICO_GPIO_14,
N    //MICO_GPIO_15,
N    //MICO_GPIO_16,
N    //MICO_GPIO_17,
N    MICO_GPIO_18,
N    MICO_GPIO_19,
N    MICO_GPIO_20,
N    MICO_GPIO_21,
N    MICO_GPIO_22,
N    MICO_GPIO_23,
N    //MICO_GPIO_24,
N    //MICO_GPIO_25,
N    //MICO_GPIO_26,
N    //MICO_GPIO_27,
N    //MICO_GPIO_28,
N    MICO_GPIO_29,
N    //MICO_GPIO_30,
N
N    MICO_GPIO_MAX, /* Denotes the total number of GPIO port aliases. Not a valid GPIO alias */
N} mico_gpio_t;
N
Ntypedef enum
N{
N    MICO_SPI_1,
N    MICO_SPI_MAX, /* Denotes the total number of SPI port aliases. Not a valid SPI alias */
N} mico_spi_t;
N
Ntypedef enum
N{
N    MICO_I2C_1,
N    MICO_I2C_MAX, /* Denotes the total number of I2C port aliases. Not a valid I2C alias */
N} mico_i2c_t;
N
Ntypedef enum
N{
N    MICO_PWM_1 = MICO_COMMON_PWM_MAX,
N    MICO_PWM_2,
N    MICO_PWM_3,
N    MICO_PWM_MAX, /* Denotes the total number of PWM port aliases. Not a valid PWM alias */
N} mico_pwm_t;
N
Ntypedef enum
N{
N    MICO_ADC_1,
N    MICO_ADC_2,
N    MICO_ADC_3,
N    MICO_ADC_MAX, /* Denotes the total number of ADC port aliases. Not a valid ADC alias */
N} mico_adc_t;
N
Ntypedef enum
N{
N    MICO_UART_1,
N    MICO_UART_2,
N    MICO_UART_MAX, /* Denotes the total number of UART port aliases. Not a valid UART alias */
N} mico_uart_t;
N
Ntypedef enum
N{
N  MICO_SPI_FLASH,
N  MICO_INTERNAL_FLASH,
N  MICO_FLASH_MAX,
N} mico_flash_t;
N
N#define STM32_UART_1 MICO_UART_1
N#define STM32_UART_2 NULL
N#define STM32_UART_6 MICO_UART_2
N
N/* Components connected to external I/Os*/
N#define Standby_SEL         (MICO_GPIO_29)
N
N/* I/O connection <-> Peripheral Connections */
N#define MICO_I2C_CP         (MICO_I2C_1)
N
N#define RestoreDefault_TimeOut          3000  /**< Restore default and start easylink after 
N                                                   press down EasyLink button for 3 seconds. */
N
N#ifdef __cplusplus
S} /*extern "C" */
N#endif
N
L 41 "..\..\..\include\MICOPlatform.h" 2
N
N#include "MicoDrivers/MICODriverUART.h"
L 1 "..\..\..\include\MicoDrivers/MICODriverUART.h" 1
N/**
N******************************************************************************
N* @file    MicoDriverUart.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    16-Sep-2014
N* @brief   This file provides all the headers of UART operation functions.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N
N#ifndef __MICODRIVERUART_H__
N#define __MICODRIVERUART_H__
N
N#pragma once
N#include "Common.h"
N#include "RingBufferUtils.h"
L 1 "..\..\..\Library\support\RingBufferUtils.h" 1
N/**
N******************************************************************************
N* @file    StringUtils.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    05-May-2014
N* @brief   This header contains function prototypes called by ring buffer 
N*          operation
N******************************************************************************
N* @attention
N*
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N* TIME. AS A RESULT, MXCHIP Inc. SHALL NOT BE HELD LIABLE FOR ANY
N* DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N* FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N* CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*
N* <h2><center>&copy; COPYRIGHT 2014 MXCHIP Inc.</center></h2>
N******************************************************************************
N*/ 
N
N#ifndef __RingBufferUtils_h__
N#define __RingBufferUtils_h__
N
N#include "Common.h"
N
Ntypedef struct
N{
N  uint32_t  size;
N  uint32_t  head;
N  uint32_t  tail;
N  uint8_t*  buffer;
N} ring_buffer_t;
N
N#ifndef MIN
N#define MIN(x,y)  ((x) < (y) ? (x) : (y))
N#endif /* ifndef MIN */
N
NOSStatus ring_buffer_init( ring_buffer_t* ring_buffer, uint8_t* buffer, uint32_t size );
N
NOSStatus ring_buffer_deinit( ring_buffer_t* ring_buffer );
N
Nuint32_t ring_buffer_free_space( ring_buffer_t* ring_buffer );
N
Nuint32_t ring_buffer_used_space( ring_buffer_t* ring_buffer );
N
Nuint8_t ring_buffer_get_data( ring_buffer_t* ring_buffer, uint8_t** data, uint32_t* contiguous_bytes );
N
Nuint8_t ring_buffer_consume( ring_buffer_t* ring_buffer, uint32_t bytes_consumed );
N
Nuint32_t ring_buffer_write( ring_buffer_t* ring_buffer, const uint8_t* data, uint32_t data_length );
N
N#endif // __RingBufferUtils_h__
N
N
L 39 "..\..\..\include\MicoDrivers/MICODriverUART.h" 2
N#include "platform.h"
N
N/** @addtogroup MICO_PLATFORM
N* @{
N*/
N
N/******************************************************
N *                   Enumerations
N ******************************************************/
N
Ntypedef enum
N{
N    DATA_WIDTH_5BIT,
N    DATA_WIDTH_6BIT,
N    DATA_WIDTH_7BIT,
N    DATA_WIDTH_8BIT,
N    DATA_WIDTH_9BIT
N} mico_uart_data_width_t;
N
Ntypedef enum
N{
N    STOP_BITS_1,
N    STOP_BITS_2,
N} mico_uart_stop_bits_t;
N
Ntypedef enum
N{
N    FLOW_CONTROL_DISABLED,
N    FLOW_CONTROL_CTS,
N    FLOW_CONTROL_RTS,
N    FLOW_CONTROL_CTS_RTS
N} mico_uart_flow_control_t;
N
Ntypedef enum
N{
N    NO_PARITY,
N    ODD_PARITY,
N    EVEN_PARITY,
N} mico_uart_parity_t;
N
N#define UART_WAKEUP_MASK_POSN   0
N#define UART_WAKEUP_DISABLE    (0 << UART_WAKEUP_MASK_POSN) /**< UART can not wakeup MCU from stop mode */
N#define UART_WAKEUP_ENABLE     (1 << UART_WAKEUP_MASK_POSN) /**< UART can wake up MCU from stop mode */
N
N
N/******************************************************
N *                    Structures
N ******************************************************/
N
N typedef struct
N{
N    uint32_t                  baud_rate;
N    mico_uart_data_width_t    data_width;
N    mico_uart_parity_t        parity;
N    mico_uart_stop_bits_t     stop_bits;
N    mico_uart_flow_control_t  flow_control;
N    uint8_t                   flags;          /**< if set, UART can wake up MCU from stop mode, reference: @ref UART_WAKEUP_DISABLE and @ref UART_WAKEUP_ENABLE*/
N} mico_uart_config_t;
N
N/******************************************************
N *                 Type Definitions
N ******************************************************/
N
N/******************************************************
N *                 Function Declarations
N ******************************************************/
N
N/** @defgroup MICO_UART MICO UART Driver
N* @brief  Universal Asynchronous Receiver Transmitter (UART) Functions
N* @{
N*/
N
N
N/** Initialises a UART interface
N *
N * Prepares an UART hardware interface for communications
N *
N * @param  uart     : the interface which should be initialised
N * @param  config   : UART configuration structure
N * @param  optional_rx_buffer : Pointer to an optional RX ring buffer
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoUartInitialize( mico_uart_t uart, const mico_uart_config_t* config, ring_buffer_t* optional_rx_buffer );
N
N
N/** Initialises a STDIO UART interface, internal use only
N *
N * Prepares an UART hardware interface for stdio communications
N *
N * @param  config   : UART configuration structure
N * @param  optional_rx_buffer : Pointer to an optional RX ring buffer
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoStdioUartInitialize( const mico_uart_config_t* config, ring_buffer_t* optional_rx_buffer );
N
N
N/** Deinitialises a UART interface
N *
N * @param  uart : the interface which should be deinitialised
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoUartFinalize( mico_uart_t uart );
N
N
N/** Transmit data on a UART interface
N *
N * @param  uart     : the UART interface
N * @param  data     : pointer to the start of data
N * @param  size     : number of bytes to transmit
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoUartSend( mico_uart_t uart, const void* data, uint32_t size );
N
N
N/** Receive data on a UART interface
N *
N * @param  uart     : the UART interface
N * @param  data     : pointer to the buffer which will store incoming data
N * @param  size     : number of bytes to receive
N * @param  timeout  : timeout in milisecond
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoUartRecv( mico_uart_t uart, void* data, uint32_t size, uint32_t timeout );
N
N/** Read the length of the data that is already recived by uart driver and stored in buffer
N *
N * @param  uart     : the UART interface
N *
N * @return    Data length
N */
Nuint32_t MicoUartGetLengthInBuffer( mico_uart_t uart ); 
N
N/** @} */
N/** @} */
N
N#endif
L 43 "..\..\..\include\MICOPlatform.h" 2
N#include "MicoDrivers/MICODriverGpio.h"
L 1 "..\..\..\include\MicoDrivers/MICODriverGpio.h" 1
N/**
N******************************************************************************
N* @file    MicoDriverGpio.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    16-Sep-2014
N* @brief   This file provides all the headers of GPIO operation functions.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N#ifndef __MICODRIVERGPIO_H__
N#define __MICODRIVERGPIO_H__
N
N#pragma once
N#include "Common.h"
N#include "platform.h"
N
N/** @addtogroup MICO_PLATFORM
N* @{
N*/
N
N/******************************************************
N *                   Macros
N ******************************************************/  
N
N#define MicoGpioInputGet wiced_gpio_input_get
N
N/******************************************************
N *                   Enumerations
N ******************************************************/
N
N typedef enum
N{
N    INPUT_PULL_UP,                  /**< Input with an internal pull-up resistor - use with devices that actively drive the signal low - e.g. button connected to ground */
N    INPUT_PULL_DOWN,                /**< Input with an internal pull-down resistor - use with devices that actively drive the signal high - e.g. button connected to a power rail */
N    INPUT_HIGH_IMPEDANCE,           /**< Input - must always be driven, either actively or by an external pullup resistor */
N    OUTPUT_PUSH_PULL,               /**< Output actively driven high and actively driven low - must not be connected to other active outputs - e.g. LED output */
N    OUTPUT_OPEN_DRAIN_NO_PULL,      /**< Output actively driven low but is high-impedance when set high - can be connected to other open-drain/open-collector outputs. Needs an external pull-up resistor */
N    OUTPUT_OPEN_DRAIN_PULL_UP,      /**< Output actively driven low and is pulled high with an internal resistor when set high - can be connected to other open-drain/open-collector outputs. */
N} mico_gpio_config_t;
N
Ntypedef enum
N{
N    IRQ_TRIGGER_RISING_EDGE  = 0x1, /**< Interrupt triggered at input signal's rising edge  */
N    IRQ_TRIGGER_FALLING_EDGE = 0x2, /**< Interrupt triggered at input signal's falling edge */
N    IRQ_TRIGGER_BOTH_EDGES   = IRQ_TRIGGER_RISING_EDGE | IRQ_TRIGGER_FALLING_EDGE, /**< Interrupt triggered at input signal's rising or falling edge */
N} mico_gpio_irq_trigger_t;
N
N/******************************************************
N *                 Type Definitions
N ******************************************************/
N
N /******************************************************
N *                 Function Declarations
N ******************************************************/
N
Ntypedef void (*mico_gpio_irq_handler_t)( void* arg );
N
N/** @defgroup MICO_GPIO MICO GPIO Driver
N* @brief  General Purpose Input/Output pin (GPIO) Functions
N* @{
N*/
N
N/** Initialises a GPIO pin
N *
N * Prepares a GPIO pin for use.
N *
N * @param gpio          : the gpio pin which should be initialised
N * @param configuration : A structure containing the required
N *                        gpio configuration
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoGpioInitialize( mico_gpio_t gpio, mico_gpio_config_t configuration );
N
N
N/** DeInitialises a GPIO pin
N *
N * Set a GPIO pin in default state.
N *
N * @param gpio          : the gpio pin which should be deinitialised
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoGpioFinalize( mico_gpio_t gpio );
N
N
N/** Sets an output GPIO pin high
N *
N * Sets an output GPIO pin high. Using this function on a
N * gpio pin which is set to input mode is undefined.
N *
N * @param gpio          : the gpio pin which should be set high
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoGpioOutputHigh( mico_gpio_t gpio );
N
N
N/** Sets an output GPIO pin low
N *
N * Sets an output GPIO pin low. Using this function on a
N * gpio pin which is set to input mode is undefined.
N *
N * @param gpio          : the gpio pin which should be set low
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoGpioOutputLow( mico_gpio_t gpio );
N
N/** Trigger an output GPIO pin 
N *
N * Trigger an output GPIO pin's output. Using this function on a
N * gpio pin which is set to input mode is undefined.
N *
N * @param gpio          : the gpio pin which should be set low
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoGpioOutputTrigger( mico_gpio_t gpio );
N
N
N
N/** Get the state of an input GPIO pin
N *
N * Get the state of an input GPIO pin. Using this function on a
N * gpio pin which is set to output mode will return an undefined value.
N *
N * @param gpio          : the gpio pin which should be read
N *
N * @return    true  : if high
N * @return    fasle : if low
N */
Nbool MicoGpioInputGet( mico_gpio_t gpio );
X_Bool wiced_gpio_input_get( mico_gpio_t gpio );
N
N
N/** Enables an interrupt trigger for an input GPIO pin
N *
N * Enables an interrupt trigger for an input GPIO pin.
N * Using this function on a gpio pin which is set to
N * output mode is undefined.
N *
N * @param gpio    : the gpio pin which will provide the interrupt trigger
N * @param trigger : the type of trigger (rising/falling edge)
N * @param handler : a function pointer to the interrupt handler
N * @param arg     : an argument that will be passed to the
N *                  interrupt handler
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoGpioEnableIRQ( mico_gpio_t gpio, mico_gpio_irq_trigger_t trigger, mico_gpio_irq_handler_t handler, void* arg );
N
N
N/** Disables an interrupt trigger for an input GPIO pin
N *
N * Disables an interrupt trigger for an input GPIO pin.
N * Using this function on a gpio pin which has not been set up
N * using @ref wiced_gpio_input_irq_enable is undefined.
N *
N * @param gpio    : the gpio pin which provided the interrupt trigger
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoGpioDisableIRQ( mico_gpio_t gpio );
N
N/** @} */
N/** @} */
N
N#endif
N
N
L 44 "..\..\..\include\MICOPlatform.h" 2
N#include "MicoDrivers/MICODriverPwm.h"
L 1 "..\..\..\include\MicoDrivers/MICODriverPwm.h" 1
N/**
N******************************************************************************
N* @file    MicoDriverPwm.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    16-Sep-2014
N* @brief   This file provides all the headers of PWM operation functions.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N#ifndef __MICODRIVERPWM_H__
N#define __MICODRIVERPWM_H__
N
N#pragma once
N#include "Common.h"
N#include "platform.h"
N
N/** @addtogroup MICO_PLATFORM
N* @{
N*/
N
N/******************************************************
N *                   Enumerations
N ******************************************************/
N
N/******************************************************
N *                 Type Definitions
N ******************************************************/
N
N /******************************************************
N *                 Function Declarations
N ******************************************************/
N
N/** @defgroup MICO_PWM MICO PWM Driver
N* @brief  Pulse-Width Modulation (PWM) Functions
N* @{
N*/
N
N/** Initialises a PWM pin
N *
N * Prepares a Pulse-Width Modulation pin for use.
N * Does not start the PWM output (use @ref wiced_pwm_start).
N *
N * @param pwm        : the PWM interface which should be initialised
N * @param frequency  : Output signal frequency in Hertz
N * @param duty_cycle : Duty cycle of signal as a floating-point percentage (0.0 to 100.0)
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoPwmInitialize(mico_pwm_t pwm, uint32_t frequency, float duty_cycle);
N
N
N/** Starts PWM output on a PWM interface
N *
N * Starts Pulse-Width Modulation signal output on a PWM pin
N *
N * @param pwm        : the PWM interface which should be started
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoPwmStart(mico_pwm_t pwm);
N
N
N/** Stops output on a PWM pin
N *
N * Stops Pulse-Width Modulation signal output on a PWM pin
N *
N * @param pwm        : the PWM interface which should be stopped
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoPwmStop(mico_pwm_t pwm);
N
N/** @} */
N/** @} */
N
N#endif
L 45 "..\..\..\include\MICOPlatform.h" 2
N#include "MicoDrivers/MICODriverSpi.h"
L 1 "..\..\..\include\MicoDrivers/MICODriverSpi.h" 1
N/**
N******************************************************************************
N* @file    MicoDriverSpi.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    16-Sep-2014
N* @brief   This file provides all the headers of SPi operation functions.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N#ifndef __MICODRIVERSPI_H__
N#define __MICODRIVERSPI_H__
N
N#pragma once
N#include "Common.h"
N#include "platform.h"
N
N/** @addtogroup MICO_PLATFORM
N* @{
N*/
N
N/******************************************************
N *                    Constants
N ******************************************************/
N/* SPI mode constants */
N#define SPI_CLOCK_RISING_EDGE  ( 1 << 0 )
N#define SPI_CLOCK_FALLING_EDGE ( 0 << 0 )
N#define SPI_CLOCK_IDLE_HIGH    ( 1 << 1 )
N#define SPI_CLOCK_IDLE_LOW     ( 0 << 1 )
N#define SPI_USE_DMA            ( 1 << 2 )
N#define SPI_NO_DMA             ( 0 << 2 )
N#define SPI_MSB_FIRST          ( 1 << 3 )
N#define SPI_LSB_FIRST          ( 0 << 3 )
N
N
N/******************************************************
N *                   Enumerations
N ******************************************************/
N
N
N/******************************************************
N *                    Structures
N ******************************************************/
N
N
Ntypedef struct
N{
N    mico_spi_t  port;
N    mico_gpio_t chip_select;
N    uint32_t     speed;
N    uint8_t      mode;
N    uint8_t      bits;
N} mico_spi_device_t;
N
Ntypedef struct
N{
N    const void* tx_buffer;
N    void*       rx_buffer;
N    uint32_t    length;
N} mico_spi_message_segment_t;
N
N/******************************************************
N *                     Variables
N ******************************************************/
N
N#ifdef MICO_PLATFORM_INCLUDES_SPI_FLASH
Sextern mico_spi_device_t mico_spi_flash;
N#endif
N
N/******************************************************
N *                 Function Declarations
N ******************************************************/
N
N/** @defgroup MICO_SPI MICO SPI Driver
N* @brief  Serial Peripheral Interface (SPI) Functions
N* @{
N*/
N
N/** Initialises the SPI interface for a given SPI device
N *
N * Prepares a SPI hardware interface for communication as a master
N *
N * @param  spi : the SPI device to be initialised
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if the SPI device could not be initialised
N */
NOSStatus MicoSpiInitialize( const mico_spi_device_t* spi );
N
N
N/** Transmits and/or receives data from a SPI device
N *
N * @param  spi      : the SPI device to be initialised
N * @param  segments : a pointer to an array of segments
N * @param  number_of_segments : the number of segments to transfer
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred
N */
NOSStatus MicoSpiTransfer( const mico_spi_device_t* spi, mico_spi_message_segment_t* segments, uint16_t number_of_segments );
N
N
N/** De-initialises a SPI interface
N *
N * Turns off a SPI hardware interface
N *
N * @param  spi : the SPI device to be de-initialised
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred
N */
NOSStatus MicoSpiFinalize( const mico_spi_device_t* spi );
N
N/** @} */
N/** @} */
N
N#endif
L 46 "..\..\..\include\MICOPlatform.h" 2
N#include "MicoDrivers/MICODriverI2c.h"
L 1 "..\..\..\include\MicoDrivers/MICODriverI2c.h" 1
N/**
N******************************************************************************
N* @file    MicoDriverI2C.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    16-Sep-2014
N* @brief   This file provides all the headers of I2C operation functions.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N#ifndef __MICODRIVERI2C_H__
N#define __MICODRIVERI2C_H__
N
N#pragma once
N#include "common.h"
N#include "platform.h"
N
N/** @addtogroup MICO_PLATFORM
N* @{
N*/
N
N/******************************************************
N *                   Macros
N ******************************************************/  
N
N/******************************************************
N *                   Enumerations
N ******************************************************/
N
Ntypedef enum
N{
N    I2C_ADDRESS_WIDTH_7BIT,     /**< I2C device has 7bit address */
N    I2C_ADDRESS_WIDTH_10BIT,    /**< I2C device has 10bit address */
N    I2C_ADDRESS_WIDTH_16BIT,    /**< I2C device has 16bit address */
N} mico_i2c_bus_address_width_t;
N
Ntypedef enum
N{
N    I2C_LOW_SPEED_MODE,         /**< I2C clock speed for 10Khz devices */
N    I2C_STANDARD_SPEED_MODE,    /**< I2C clock speed for 100Khz devices */
N    I2C_HIGH_SPEED_MODE         /**< I2C clock speed for 400Khz devices */
N} mico_i2c_speed_mode_t;
N
N/******************************************************
N *                    Structures
N ******************************************************/
N
Ntypedef struct
N{
N    mico_i2c_t                    port;           /**< Platform I2C port that is connected to the target I2C device, - e.g. MICO_I2C_1 */
N    uint16_t                      address;        /**< The address of the device on the I2C bus */
N    mico_i2c_bus_address_width_t  address_width;  /**< I2C device's address length */
N    mico_i2c_speed_mode_t         speed_mode;     /**< Speed mode the device operates in */
N} mico_i2c_device_t;
N
Ntypedef struct
N{
N    const void*  tx_buffer;  /**< A pointer to the data to be transmitted. If NULL, the message is an RX message when 'combined' is FALSE */
N    void*        rx_buffer;  /**< A pointer to the data to be transmitted. If NULL, the message is an TX message when 'combined' is FALSE */
N    uint16_t     tx_length;  /**< Number of bytes to transmit */
N    uint16_t     rx_length;  /**< Number of bytes to receive */
N    uint16_t     retries;    /**< Number of times to retry the message */
N    bool combined;           /**< If set, this message is used for both tx and rx. */
X    _Bool combined;            
N} mico_i2c_message_t;
N
N/******************************************************
N *                 Type Definitions
N ******************************************************/
N
N/******************************************************
N *                 Function Declarations
N ******************************************************/
N
N/** @defgroup MICO_I2C MICO I2C Driver
N* @brief  Inter-IC bus (I2C) Functions
N* @{
N*/
N
N/** Initialises an I2C interface
N *
N * Prepares an I2C hardware interface for communication as a master
N *
N * @param  device : the device for which the i2c port should be initialised
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred during initialisation
N */
NOSStatus MicoI2cInitialize( mico_i2c_device_t* device );
N
N
N/** Checks whether the device is available on a bus or not
N *
N *
N * @param  device : the i2c device to be probed
N * @param  retries    : the number of times to attempt to probe the device
N *
N * @return    true : device is found.
N * @return    false: device is not found
N */
Nbool MicoI2cProbeDevice( mico_i2c_device_t* device, int retries );
X_Bool MicoI2cProbeDevice( mico_i2c_device_t* device, int retries );
N
N
N/** Initialize the mico_i2c_message_t structure for i2c tx transaction
N *
N * @param message : pointer to a message structure, this should be a valid pointer
N * @param tx_buffer : pointer to a tx buffer that is already allocated
N * @param tx_buffer_length : number of bytes to transmit
N * @param retries    : the number of times to attempt send a message in case it can't not be sent
N *
N * @return    kNoErr    : message structure was initialised properly.
N * @return    kParamErr : one of the arguments is given incorrectly
N */
NOSStatus MicoI2cBuildTxMessage(mico_i2c_message_t* message, const void* tx_buffer, uint16_t  tx_buffer_length, uint16_t retries);
N
N/** Initialize the mico_i2c_message_t structure for i2c rx transaction
N *
N * @param message : pointer to a message structure, this should be a valid pointer
N * @param rx_buffer : pointer to an rx buffer that is already allocated
N * @param rx_buffer_length : number of bytes to receive
N * @param retries    : the number of times to attempt receive a message in case device doesnt respond
N *
N * @return    kNoErr    : message structure was initialised properly.
N * @return    kParamErr : one of the arguments is given incorrectly
N */
NOSStatus MicoI2cBuildRxMessage(mico_i2c_message_t* message, void* rx_buffer, uint16_t rx_buffer_length, uint16_t retries);
N
N
N/** Initialize the mico_i2c_message_t structure for i2c combined transaction
N *
N * @param  message : pointer to a message structure, this should be a valid pointer
N * @param tx_buffer: pointer to a tx buffer that is already allocated
N * @param rx_buffer: pointer to an rx buffer that is already allocated
N * @param tx_buffer_length: number of bytes to transmit
N * @param rx_buffer_length: number of bytes to receive
N * @param  retries    : the number of times to attempt receive a message in case device doesnt respond
N *
N * @return    kNoErr    : message structure was initialised properly.
N * @return    kParamErr : one of the arguments is given incorrectly
N */
NOSStatus MicoI2cBuildCombinedMessage(mico_i2c_message_t* message, const void* tx_buffer, void* rx_buffer, uint16_t tx_buffer_length, uint16_t rx_buffer_length, uint16_t retries);
N
N
N/** Transmits and/or receives data over an I2C interface
N *
N * @param  device             : the i2c device to communicate with
N * @param  message            : a pointer to a message (or an array of messages) to be transmitted/received
N * @param  number_of_messages : the number of messages to transfer. [1 .. N] messages
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred during message transfer
N */
NOSStatus MicoI2cTransfer( mico_i2c_device_t* device, mico_i2c_message_t* message, uint16_t number_of_messages );
N
N
N/** Deinitialises an I2C device
N *
N * @param  device : the device for which the i2c port should be deinitialised
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred during deinitialisation
N */
NOSStatus MicoI2cFinalize( mico_i2c_device_t* device );
N
N
N/** @} */
N/** @} */
N
N#endif
N
N
L 47 "..\..\..\include\MICOPlatform.h" 2
N#include "MicoDrivers/MICODriverRtc.h"
L 1 "..\..\..\include\MicoDrivers/MICODriverRtc.h" 1
N/**
N******************************************************************************
N* @file    MicoDriverRtc.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    16-Sep-2014
N* @brief   This file provides all the headers of RTC operation functions.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N#ifndef __MICODRIVERRTC_H__
N#define __MICODRIVERRTC_H__
N
N#pragma once
N#include "Common.h"
N#include "platform.h"
N
N/** @addtogroup MICO_PLATFORM
N* @{
N*/
N
N/******************************************************
N *                   Macros
N ******************************************************/  
N
N/******************************************************
N *                   Enumerations
N ******************************************************/
N
N/******************************************************
N *                 Type Definitions
N ******************************************************/
N
N /******************************************************
N *                    Structures
N ******************************************************/
N
Ntypedef struct
N{
N    uint8_t sec;  /*!< Specifies the RTC Time Seconds.
N                       This parameter must be set to a value in the 0-59 range. */
N
N    uint8_t min;  /*!< Specifies the RTC Time Minutes.
N                       This parameter must be set to a value in the 0-59 range. */
N
N    uint8_t hr;   /*!< Specifies the RTC Time Hour.
N                       This parameter must be set to a value in the 0-23 range. */
N
N    uint8_t weekday;  /*!< Specifies the RTC Date WeekDay.
N                           This parameter can be a value of @ref RTC_WeekDay_Definitions */
N
N    uint8_t date;     /*!< Specifies the RTC Date.
N                           This parameter must be set to a value in the 1-31 range. */
N
N    uint8_t month;    /*!< Specifies the RTC Date Month (in BCD format).
N                           This parameter can be a value of @ref RTC_Month_Date_Definitions */
N
N    uint8_t year;     /*!< Specifies the RTC Date Year.
N                        This parameter must be set to a value in the 0-99 range. */
N}mico_rtc_time_t;
N
N/******************************************************
N *                     Variables
N ******************************************************/
N
N/******************************************************
N                Function Declarations
N ******************************************************/
N
N/** @defgroup MICO_RTC MICO RTC Driver
N* @brief  Real-time clock (RTC) Functions
N* @{
N*/
N
N/**
N * This function will initialize the on board CPU real time clock
N *
N * @note  This function should be called by MICO system when initializing clocks, so
N *        It is not needed to be called by application
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
Nvoid MicoRtcInitialize(void);
N
N/**
N * This function will return the value of time read from the on board CPU real time clock. Time value must be given in the format of
N * the structure wiced_rtc_time_t
N *
N * @param time        : pointer to a time structure
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoRtcGetTime(mico_rtc_time_t* time);
N
N/**
N * This function will set MCU RTC time to a new value. Time value must be given in the format of
N * the structure wiced_rtc_time_t
N *
N * @param time        : pointer to a time structure
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoRtcSetTime(mico_rtc_time_t* time);
N
N/** @} */
N/** @} */
N
N#endif
N
N
L 48 "..\..\..\include\MICOPlatform.h" 2
N#include "MicoDrivers/MICODriverWdg.h"
L 1 "..\..\..\include\MicoDrivers/MICODriverWdg.h" 1
N/**
N******************************************************************************
N* @file    MicoDriverWdg.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    16-Sep-2014
N* @brief   This file provides all the headers of WDG operation functions.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N
N#ifndef __MICODRIVERWDG_H__
N#define __MICODRIVERWDG_H__
N
N#pragma once
N#include "Common.h"
N#include "platform.h"
N
N/** @addtogroup MICO_PLATFORM
N* @{
N*/
N
N/******************************************************
N *                   Macros
N ******************************************************/  
N
N#define PlatformWDGInitialize   MicoWdgInitialize /**< For API compatiable with older version */
N#define PlatformWDGReload       MicoWdgReload     /**< For API compatiable with older version */
N#define PlatformWDGFinalize     MicoWdgFinalize   /**< For API compatiable with older version */
N
N/******************************************************
N *@cond              Enumerations
N ******************************************************/
N
N/******************************************************
N *@endcond         Type Definitions
N ******************************************************/
N
N /******************************************************
N *                    Structures
N ******************************************************/
N
N
N/******************************************************
N *                     Variables
N ******************************************************/
N
N/******************************************************
N * @endcond           Function Declarations
N ******************************************************/
N
N/** @defgroup MICO_WDG MICO WDG Driver
N* @brief  Hardware watch dog Functions (WDG) Functions
N* @note   These Functions are used by MICO's system monitor service, If any defined system monitor 
N*          cannot be reloaded for some reason, system monitor service use this hardware watch dog 
N*          to perform a system reset. So the watch dog reload time should be greater than system 
N*          monitor's refresh time.
N* @{
N*/
N
N/**
N * This function will initialize the on board CPU hardware watch dog
N *
N * @param timeout        : Watchdag timeout, application should call MicoWdgReload befor timeout.
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoWdgInitialize( uint32_t timeout );
N
N/**
N * Reload watchdog counter.
N *
N * @param     none
N * @return    none
N */
Nvoid MicoWdgReload( void );
N
N/**
N * This function performs any platform-specific cleanup needed for hardware watch dog.
N *
N * @param     none
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoWdgFinalize( void );
N
N/** @} */
N/** @} */
N
N#endif
N
N
L 49 "..\..\..\include\MICOPlatform.h" 2
N#include "MicoDrivers/MICODriverAdc.h"
L 1 "..\..\..\include\MicoDrivers/MICODriverAdc.h" 1
N/**
N******************************************************************************
N* @file    MicoDriverAdc.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    16-Sep-2014
N* @brief   This file provides all the headers of ADC operation functions.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N#ifndef __MICODRIVERADC_H__
N#define __MICODRIVERADC_H__
N
N#pragma once
N#include "Common.h"
N#include "platform.h"
N
N/** @addtogroup MICO_PLATFORM
N* @{
N*/
N
N
N/******************************************************
N *                   Macros
N ******************************************************/  
N
N/******************************************************
N *                   Enumerations
N ******************************************************/
N
N/******************************************************
N *                 Type Definitions
N ******************************************************/
N
N /******************************************************
N *                    Structures
N ******************************************************/
N
N/******************************************************
N *                     Variables
N ******************************************************/
N
N/******************************************************
N * @endcond           Function Declarations
N ******************************************************/
N
N/** @defgroup MICO_ADC MICO ADC Driver
N* @brief  Analog to Digital Converter (ADC) Functions
N* @{
N*/
N
N/** Initialises an ADC interface
N *
N * Prepares an ADC hardware interface for sampling
N *
N * @param adc            : the interface which should be initialised
N * @param sampling_cycle : sampling period in number of ADC clock cycles. If the
N *                         MCU does not support the value provided, the closest
N *                         supported value is used.
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoAdcInitialize( mico_adc_t adc, uint32_t sampling_cycle );
N
N
N
N/** Takes a single sample from an ADC interface
N *
N * Takes a single sample from an ADC interface
N *
N * @param adc    : the interface which should be sampled
N * @param output : pointer to a variable which will receive the sample
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoAdcTakeSample( mico_adc_t adc, uint16_t* output );
N
N
N/** Takes multiple samples from an ADC interface
N *
N * Takes multiple samples from an ADC interface and stores them in
N * a memory buffer
N *
N * @param adc           : the interface which should be sampled
N * @param buffer        : a memory buffer which will receive the samples
N *                        Each sample will be uint16_t little endian.
N * @param buffer_length : length in bytes of the memory buffer.
N *
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoAdcTakeSampleStreram( mico_adc_t adc, void* buffer, uint16_t buffer_length );
N
N
N/** De-initialises an ADC interface
N *
N * Turns off an ADC hardware interface
N *
N * @param  adc : the interface which should be de-initialised
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus  MicoAdcFinalize( mico_adc_t adc );
N
N/** @} */
N/** @} */
N#endif
L 50 "..\..\..\include\MICOPlatform.h" 2
N#include "MicoDrivers/MICODriverRng.h"
L 1 "..\..\..\include\MicoDrivers/MICODriverRng.h" 1
N/**
N******************************************************************************
N* @file    MicoDriverRng.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    16-Sep-2014
N* @brief   This file provides all the headers of RNG operation functions.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N#ifndef __MICODRIVERRNG_H__
N#define __MICODRIVERRNG_H__
N
N#pragma once
N#include "Common.h"
N#include "platform.h"
N
N
N
N/** @addtogroup MICO_PLATFORM
N* @{
N*/
N
N/******************************************************
N *@cond             Macros
N ******************************************************/  
N
N#define PlatformRandomBytes MicoRandomNumberRead   /**< For API compatiable with older version */
N
N/******************************************************
N *@endcond           Enumerations
N ******************************************************/
N
N
N/******************************************************
N *                 Type Definitions
N ******************************************************/
N
N /******************************************************
N *                 Function Declarations
N ******************************************************/
N 
N/** @defgroup MICO_RNG MICO RNG Driver
N * @brief  Random Number Generater(RNG) Functions
N * @{
N */
N
N/** Fill in a memory buffer with random data
N *
N * @param inBuffer        : Point to a valid memory buffer, this function will fill 
N                            in this memory with random numbers after excuted
N * @param inByteCount     : Length of the memory buffer (bytes)
N *
N * @return    kNoErr        : on success.
N * @return    kGeneralErr   : if an error occurred with any step
N */
NOSStatus MicoRandomNumberRead( void *inBuffer, int inByteCount );
N
N/** @} */
N/** @} */
N
N#endif
N
N
L 51 "..\..\..\include\MICOPlatform.h" 2
N#include "MicoDrivers/MICODriverFlash.h"
L 1 "..\..\..\include\MicoDrivers/MICODriverFlash.h" 1
N/**
N******************************************************************************
N* @file    MicoDriverFlash.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    16-Sep-2014
N* @brief   This file provides all the headers of flash operation functions.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N#ifndef __MICODRIVERFLASH_H__
N#define __MICODRIVERFLASH_H__
N
N#pragma once
N#include "Common.h"
N#include "platform.h"
N
N/** @addtogroup MICO_PLATFORM
N* @{
N*/
N
N/******************************************************
N *                   Macros
N ******************************************************/  
N
N/******************************************************
N *                   Enumerations
N ******************************************************/
N
N/******************************************************
N *                 Type Definitions
N ******************************************************/
N
N/******************************************************
N *                 Global Variables
N ******************************************************/
N
Nextern const char*  flash_name[];  /**< A name string of a Flash drive */
N
N /******************************************************
N *                 Function Declarations
N ******************************************************/
N
N/** @defgroup MICO_FLASH MICO Flash Driver
N* @brief  Flash operation Functions
N* @{
N*/
N
N/** Initialises a Flash driver
N *
N * Prepares an Flash for read and write
N *
N * @param  inFlash     : the interface which should be initialised
N *
N * @return    kNoErr        : On success.
N * @return    kGeneralErr   : If an error occurred with any step
N */
NOSStatus MicoFlashInitialize( mico_flash_t inFlash );
N
N/** Erase an area on a Flash
N *
N * @note Erase on an address will erase all data on a sector that the 
N *       address is belonged to, this function does not save data that
N *       beyond the address area but in the affected sector, the data
N *       will be lost.
N *
N * @param  inFlash     		: The target flash which should be erased
N * @param  inStartAddress 	: Start address of the erased flash area
N * @param  inEndAddress   	: End address of the erased flash area
N *
N * @return    kNoErr        : On success.
N * @return    kGeneralErr   : If an error occurred with any step
N */
NOSStatus MicoFlashErase(mico_flash_t inFlash, uint32_t inStartAddress, uint32_t inEndAddress);
N
N/** Write data to an area on a Flash
N *
N * @param  inFlash     	  : The target flash which should be written
N * @param  inFlashAddress : Poing to the start address that the data is written to, and
N *                          point to the last unwritten address after this function is 
N *                          returned, so you can call this function serval times without
N *                          update this start address.
N * @param  inBuffer       : point to the data buffer that will be written to flash
N * @param  inBufferLength : The length of the buffer
N *
N * @return    kNoErr        : On success.
N * @return    kGeneralErr   : If an error occurred with any step
N */
NOSStatus MicoFlashWrite(mico_flash_t inFlash, volatile uint32_t* inFlashAddress, uint8_t* inBuffer ,uint32_t inBufferLength);
N
N/** Read data from an area on a Flash to data buffer in RAM
N *
N * @param  inFlash     	  : The target flash which should be  read
N * @param  inFlashAddress : Poing to the start address that the data is read, and
N *                          point to the last unread address after this function is 
N *                          returned, so you can call this function serval times without
N *                          update this start address.
N * @param  outBuffer      : point to the data buffer that stores the data read from flash
N * @param  inBufferLength : The length of the buffer
N *
N * @return    kNoErr        : On success.
N * @return    kGeneralErr   : If an error occurred with any step
N */
NOSStatus MicoFlashRead(mico_flash_t inFlash, volatile uint32_t* inFlashAddress, uint8_t* outBuffer ,uint32_t inBufferLength);
N
N/** Deinitialises a Flash driver
N *
N * Prepares an Flash for read and write
N *
N * @param  inFlash     : The target flash which should be deinitialised
N *
N * @return    kNoErr        : On success.
N * @return    kGeneralErr   : If an error occurred with any step
N */
NOSStatus MicoFlashFinalize( mico_flash_t inFlash );
N
N
N
N/** @} */
N/** @} */
N
N#endif
N
N
L 52 "..\..\..\include\MICOPlatform.h" 2
N#include "MicoDrivers/MICODriverMFiAuth.h"
L 1 "..\..\..\include\MicoDrivers/MICODriverMFiAuth.h" 1
N/**
N******************************************************************************
N* @file    MicoDriverMFiAuth.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    7-Nov-2014
N* @brief   This file provides all the headers of Apple Authentication Coprocessor
N*          operations, Apple Authentication Coprocessor should be conntectd by
N*          MICO_I2C_CP defined in platform.h, and based on I2C driver defined in 
N*          MicoDriverI2c.h
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N#ifndef __MICODRIVERMFIAUTH_H__
N#define __MICODRIVERMFIAUTH_H__
N
N#pragma once
N#include "Common.h"
N
N//---------------------------------------------------------------------------------------------------------------------------
N/*! @function   PlatformMFiAuthInitialize
N    @abstract   Performs any platform-specific initialization needed. Example: Bring up I2C interface for communication with
N                the Apple Authentication Coprocessor.
N*/
NOSStatus MicoMFiAuthInitialize( void );
N
N//---------------------------------------------------------------------------------------------------------------------------
N/*! @function   PlatformMFiAuthFinalize
N    @abstract   Performs any platform-specific cleanup needed. Example: Bringing down the I2C interface for communication with
N                the Apple Authentication Coprocessor.
N*/
Nvoid MicoMFiAuthFinalize( void );
N
N//---------------------------------------------------------------------------------------------------------------------------
N/*! @function   PlatformMFiAuthCreateSignature
N    @abstract   Create an RSA signature from the specified SHA-1 digest using the Apple Authentication Coprocessor.
N
N    @param      inDigestPtr         Pointer to 20-byte SHA-1 digest.
N    @param      inDigestLen         Number of bytes in the digest. Must be 20.
N    @param      outSignaturePtr     Receives malloc()'d ptr to RSA signature. Caller must free() on success.
N    @param      outSignatureLen     Receives number of bytes in RSA signature.
N*/
NOSStatus MicoMFiAuthCreateSignature( const  void      *inDigestPtr,
N                                            size_t     inDigestLen,
N                                            uint8_t  **outSignaturePtr,
N                                            size_t    *outSignatureLen );
N
N//---------------------------------------------------------------------------------------------------------------------------
N/*! @function   PlatformMFiAuthCopyCertificate
N    @abstract   Copy the certificate from the Apple Authentication Coprocessor.
N
N    @param      outCertificatePtr   Receives malloc()'d ptr to a DER-encoded PKCS#7 message containing the certificate.
N                                    Caller must free() on success.
N    @param      outCertificateLen   Number of bytes in the DER-encoded certificate.
N*/
NOSStatus MicoMFiAuthCopyCertificate( uint8_t **outCertificatePtr, size_t *outCertificateLen );
N
N
N#endif // __MICODRIVERMFIAUTH_H__
N
N
L 53 "..\..\..\include\MICOPlatform.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define mico_mcu_powersave_config MicoMcuPowerSaveConfig
N
N/** @defgroup MICO_PLATFORM  MICO Hardware Abstract Layer APIs
N* @brief Control hardware peripherals on different platfroms using standard HAL API functions
N* 
N*/
N
N/** @addtogroup MICO_PLATFORM
N  * @{
N  */
N
N/** \defgroup platform_misc Task switching, reboot, and standby
N  @{
N */
N
N#define ENABLE_INTERRUPTS   __asm("CPSIE i")  /**< Enable interrupts to start task switching in MICO RTOS. */
N#define DISABLE_INTERRUPTS  __asm("CPSID i")  /**< Disable interrupts to stop task switching in MICO RTOS. */
N
N
N/** @brief    Software reboot the MICO hardware
N  *
N  * @param    none
N  * @return   none
N  */
Nvoid MicoSystemReboot(void);
N
N/** @brief    Software reboot the MICO hardware
N  *
N  * @param    timeToWakeup: MICO will wakeup after secondsToWakeup (seconds)
N  * @return   none
N  */
Nvoid MicoSystemStandBy(uint32_t secondsToWakeup);
N
N/** @brief    Enables the MCU to enter deep sleep mode when all threads are suspended.
N  *
N  * @note:    When all threads are suspended, mcu can shut down some peripherals to 
N  *           save power. For example, STM32 enters STOP mode in this condition, 
N  *           its peripherals are not working and needs to be wake up by an external
N  *           interrupt or MICO core's internal timer. So if you are using a peripherals,  
N  *           you should disable this function temporarily.
N  *           To make this function works, you should not disable the macro in MicoDefault.h: 
N  *           MICO_DISABLE_MCU_POWERSAVE
N  *
N  * @param    enable : 1 = enable MCU powersave, 0 = disable MCU powersave
N  * @return   none
N  */
Nvoid MicoMcuPowerSaveConfig( int enable );
N
N
N
Nvoid MicoSysLed(bool onoff);
Xvoid MicoSysLed(_Bool onoff);
N
N
N
Nvoid MicoRfLed(bool onoff);
Xvoid MicoRfLed(_Bool onoff);
N
N
Nbool MicoShouldEnterMFGMode(void);
X_Bool MicoShouldEnterMFGMode(void);
N
Nbool MicoShouldEnterBootloader(void);
X_Bool MicoShouldEnterBootloader(void);
N
N/**
N  * @}
N  */
N
N
N/**
N  * @}
N  */
N#ifdef __cplusplus
S} /*extern "C" */
N#endif
N
N
N#endif
N
L 34 "..\..\..\Platform\Common\Cortex-M3\STM32F2xx\MicoDriverGpio.c" 2
N#include "MICORTOS.h"
L 1 "..\..\..\include\MICORTOS.h" 1
N/**
N******************************************************************************
N* @file    MICORTOS.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    16-Sep-2014
N* @brief   This file provides all the headers of RTOS operation provided by MICO.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N#ifndef __MICORTOS_H__
N#define __MICORTOS_H__
N
N#include "Common.h"
N
N#define mico_thread_sleep                 sleep
N#define mico_thread_msleep                msleep
N#define mico_rtos_suspend_all_thread      vTaskSuspendAll
N#define mico_rtos_resume_all_thread       xTaskResumeAll
N
N/** @addtogroup MICO_Core_APIs
N  * @{
N  */
N
N/** @defgroup MICO_RTOS MICO RTOS Operations
N  * @{
N  */
N
N#define MICO_NEVER_TIMEOUT   (0xFFFFFFFF)
N#define MICO_WAIT_FOREVER    (0xFFFFFFFF)
N#define MICO_NO_WAIT         (0)
N
Ntypedef void (*mico_thread_function_t)( void* arg );
Ntypedef void* mico_semaphore_t;
Ntypedef void* mico_mutex_t;
Ntypedef void* mico_thread_t;
Ntypedef void* mico_queue_t;
Ntypedef void (*timer_handler_t)( void* arg );
N
Ntypedef struct
N{
N  void *          handle;
N  timer_handler_t function;
N  void*           arg;
N}mico_timer_t;
N
N/** @defgroup MICO_RTOS_Thread MICO RTOS Thread Management Functions
N *  @verbatim   
N *   MICO thread priority table
N *
N * +----------+-----------------+
N * | Priority |      Thread     |
N * |----------|-----------------|
N * |     0    |      MICO       |   Highest priority
N * |     1    |     Network     |
N * |     2    |                 |
N * |     3    | Network worker  |
N * |     4    |                 |
N * |     5    | Default Library |
N * |          | Default worker  |
N * |     6    |                 |
N * |     7    |   Application   |
N * |     8    |                 |
N * |     9    |      Idle       |   Lowest priority
N * +----------+-----------------+ 
N *  @endverbatim
N * @{
N */
N#define MICO_NETWORK_WORKER_PRIORITY      (3)
N#define MICO_DEFAULT_WORKER_PRIORITY      (5)
N#define MICO_DEFAULT_LIBRARY_PRIORITY     (5)
N#define MICO_APPLICATION_PRIORITY         (7)
N
N/** @brief Creates and starts a new thread
N  *
N  * @param thread     : Pointer to variable that will receive the thread handle (can be null)
N  * @param priority   : A priority number.
N  * @param name       : a text name for the thread (can be null)
N  * @param function   : the main thread function
N  * @param stack_size : stack size for this thread
N  * @param arg        : argument which will be passed to thread function
N  *
N  * @return    kNoErr          : on success.
N  * @return    kGeneralErr     : if an error occurred
N  */
NOSStatus mico_rtos_create_thread( mico_thread_t* thread, uint8_t priority, const char* name, mico_thread_function_t function, uint32_t stack_size, void* arg );
N
N
N/** @brief   Deletes a terminated thread
N  *
N  * @param   thread     : the handle of the thread to delete, , NULL is the current thread
N  *
N  * @return  kNoErr        : on success.
N  * @return  kGeneralErr   : if an error occurred
N  */
NOSStatus mico_rtos_delete_thread( mico_thread_t* thread );
N
N
N/** @brief    Suspend a thread
N  *
N  * @param    thread     : the handle of the thread to suspend, NULL is the current thread
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
Nvoid mico_rtos_suspend_thread(mico_thread_t* thread);
N
N
N/** @brief    Suspend all other thread
N  *
N  * @param    none
N  *
N  * @return   none
N  */
Nvoid mico_rtos_suspend_all_thread(void);
Xvoid vTaskSuspendAll(void);
N
N
N/** @brief    Rresume all other thread
N  *
N  * @param    none
N  *
N  * @return   none
N  */
Nlong mico_rtos_resume_all_thread(void);
Xlong xTaskResumeAll(void);
N
N
N/** @brief    Sleeps until another thread has terminated
N  *
N  * @Details  Causes the current thread to sleep until the specified other thread
N  *           has terminated. If the processor is heavily loaded with higher priority
N  *           tasks, this thread may not wake until significantly after the thread termination.
N  *
N  * @param    thread : the handle of the other thread which will terminate
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NOSStatus mico_rtos_thread_join( mico_thread_t* thread );
N
N
N/** @brief    Forcibly wakes another thread
N  *
N  * @Details  Causes the specified thread to wake from suspension. This will usually
N  *           cause an error or timeout in that thread, since the task it was waiting on
N  *           is not complete.
N  *
N  * @param    thread : the handle of the other thread which will be woken
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NOSStatus mico_rtos_thread_force_awake( mico_thread_t* thread );
N
N
N/** @brief    Checks if a thread is the current thread
N  *
N  * @Details  Checks if a specified thread is the currently running thread
N  *
N  * @param    thread : the handle of the other thread against which the current thread 
N  *                    will be compared
N  *
N  * @return   true   : specified thread is the current thread
N  * @return   false  : specified thread is not currently running
N  */
Nbool mico_rtos_is_current_thread( mico_thread_t* thread );
X_Bool mico_rtos_is_current_thread( mico_thread_t* thread );
N
N/** @brief    Suspend current thread for a specific time
N  *
N  * @param    timer : A time interval (Unit: seconds)
N  *
N  * @return   None.
N  */
Nvoid mico_thread_sleep(int seconds);
Xvoid sleep(int seconds);
N
N/** @brief    Suspend current thread for a specific time
N *
N * @param     timer : A time interval (Unit: millisecond)
N *
N * @return    None.
N */
Nvoid mico_thread_msleep(int milliseconds);
Xvoid msleep(int milliseconds);
N
N/** @brief    Inserts a delay time in no os.
N *
N * @param     timer : A time interval (Unit: millisecond)
N *
N * @return    None.
N */
Nvoid mico_thread_msleep_no_os(volatile uint32_t  milliseconds);
N
N/**
N  * @}
N  */
N
N/** @defgroup MICO_RTOS_SEM MICO RTOS Semaphore Functions
N  * @{
N  */
N
N/** @brief    Initialises a counting semaphore and set count to 0
N  *
N  * @param    semaphore : a pointer to the semaphore handle to be initialised
N  * @param    count     : the max count number of this semaphore
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NOSStatus mico_rtos_init_semaphore( mico_semaphore_t* semaphore, int count );
N
N
N/** @brief    Set (post/put/increment) a semaphore
N  *
N  * @param    semaphore : a pointer to the semaphore handle to be set
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NOSStatus mico_rtos_set_semaphore( mico_semaphore_t* semaphore );
N
N
N/** @brief    Get (wait/decrement) a semaphore
N  *
N  * @Details  Attempts to get (wait/decrement) a semaphore. If semaphore is at zero already,
N  *           then the calling thread will be suspended until another thread sets the
N  *           semaphore with @ref mico_rtos_set_semaphore
N  *
N  * @param    semaphore : a pointer to the semaphore handle
N  * @param    timeout_ms: the number of milliseconds to wait before returning
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NOSStatus mico_rtos_get_semaphore( mico_semaphore_t* semaphore, uint32_t timeout_ms );
N
N
N/** @brief    De-initialise a semaphore
N  *
N  * @Details  Deletes a semaphore created with @ref mico_rtos_init_semaphore
N  *
N  * @param    semaphore : a pointer to the semaphore handle
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NOSStatus mico_rtos_deinit_semaphore( mico_semaphore_t* semaphore );
N/**
N  * @}
N  */
N
N/** @defgroup MICO_RTOS_MUTEX MICO RTOS Mutex Functions
N  * @{
N  */
N
N/** @brief    Initialises a mutex
N  *
N  * @Details  A mutex is different to a semaphore in that a thread that already holds
N  *           the lock on the mutex can request the lock again (nested) without causing
N  *           it to be suspended.
N  *
N  * @param    mutex : a pointer to the mutex handle to be initialised
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NOSStatus mico_rtos_init_mutex( mico_mutex_t* mutex );
N
N
N/** @brief    Obtains the lock on a mutex
N  *
N  * @Details  Attempts to obtain the lock on a mutex. If the lock is already held
N  *           by another thead, the calling thread will be suspended until the mutex 
N  *           lock is released by the other thread.
N  *
N  * @param    mutex : a pointer to the mutex handle to be locked
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NOSStatus mico_rtos_lock_mutex( mico_mutex_t* mutex );
N
N
N/** @brief    Releases the lock on a mutex
N  *
N  * @Details  Releases a currently held lock on a mutex. If another thread
N  *           is waiting on the mutex lock, then it will be resumed.
N  *
N  * @param    mutex : a pointer to the mutex handle to be unlocked
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NOSStatus mico_rtos_unlock_mutex( mico_mutex_t* mutex );
N
N
N/** @brief    De-initialise a mutex
N  *
N  * @Details  Deletes a mutex created with @ref mico_rtos_init_mutex
N  *
N  * @param    mutex : a pointer to the mutex handle
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NOSStatus mico_rtos_deinit_mutex( mico_mutex_t* mutex );
N
N/**
N  * @}
N  */
N
N/** @defgroup MICO_RTOS_QUEUE MICO RTOS FIFO Queue Functions
N  * @{
N  */
N
N/** @brief    Initialises a FIFO queue
N  *
N  * @param    queue : a pointer to the queue handle to be initialised
N  * @param    name  : a text string name for the queue (NULL is allowed)
N  * @param    message_size : size in bytes of objects that will be held in the queue
N  * @param    number_of_messages : depth of the queue - i.e. max number of objects in the queue
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NOSStatus mico_rtos_init_queue( mico_queue_t* queue, const char* name, uint32_t message_size, uint32_t number_of_messages );
N
N
N/** @brief    Pushes an object onto a queue
N  *
N  * @param    queue : a pointer to the queue handle
N  * @param    message : the object to be added to the queue. Size is assumed to be
N  *                  the size specified in @ref mico_rtos_init_queue
N  * @param    timeout_ms: the number of milliseconds to wait before returning
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error or timeout occurred
N  */
NOSStatus mico_rtos_push_to_queue( mico_queue_t* queue, void* message, uint32_t timeout_ms );
N
N
N/** @brief    Pops an object off a queue
N  *
N  * @param    queue : a pointer to the queue handle
N  * @param    message : pointer to a buffer that will receive the object being
N  *                     popped off the queue. Size is assumed to be
N  *                     the size specified in @ref mico_rtos_init_queue , hence
N  *                     you must ensure the buffer is long enough or memory
N  *                     corruption will result
N  * @param    timeout_ms: the number of milliseconds to wait before returning
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error or timeout occurred
N  */
NOSStatus mico_rtos_pop_from_queue( mico_queue_t* queue, void* message, uint32_t timeout_ms );
N
N
N/** @brief    De-initialise a queue created with @ref mico_rtos_init_queue
N  *
N  * @param    queue : a pointer to the queue handle
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NOSStatus mico_rtos_deinit_queue( mico_queue_t* queue );
N
N
N/** @brief    Check if a queue is empty
N  *
N  * @param    queue : a pointer to the queue handle
N  *
N  * @return   true  : queue is empty.
N  * @return   false : queue is not empty.
N  */
Nbool mico_rtos_is_queue_empty( mico_queue_t* queue );
X_Bool mico_rtos_is_queue_empty( mico_queue_t* queue );
N
N
N/** @brief    Check if a queue is full
N  *
N  * @param    queue : a pointer to the queue handle
N  *
N  * @return   kNoErr        : queue is full.
N  * @return   kGeneralErr   : queue is not full.
N  */
NOSStatus mico_rtos_is_queue_full( mico_queue_t* queue );
N
N/**
N  * @}
N  */
N
N
N/** @defgroup MICO_RTOS_TIMER MICO RTOS Timer Functions
N  * @{
N  */
N
N/**
N  * @brief    Gets time in miiliseconds since RTOS start
N  *
N  * @note:    Since this is only 32 bits, it will roll over every 49 days, 17 hours.
N  *
N  * @returns  Time in milliseconds since RTOS started.
N  */
NWEAK uint32_t mico_get_time(void);
X__attribute__ ((weak)) uint32_t mico_get_time(void);
N
N/**
N  * @brief    Gets time in miiliseconds in no OS mode ( Used in bootloader )
N  *
N  * @note:    Since this is only 32 bits, it will roll over every 49 days, 17 hours.
N  *
N  * @returns  Time in milliseconds
N  */
Nuint32_t mico_get_time_no_os(void);
N
N/** 
N  * @brief     Initialize a RTOS timer
N  *
N  * @note      Timer does not start running until @ref mico_start_timer is called
N  *
N  * @param     timer    : a pointer to the timer handle to be initialised
N  * @param     time_ms  : Timer period in milliseconds
N  * @param     function : the callback handler function that is called each time the 
N  *                       timer expires
N  * @param     arg      : an argument that will be passed to the callback function
N  *
N  * @return    kNoErr        : on success.
N  * @return    kGeneralErr   : if an error occurred
N  */
NWEAK OSStatus mico_init_timer( mico_timer_t* timer, uint32_t time_ms, timer_handler_t function, void* arg );
X__attribute__ ((weak)) OSStatus mico_init_timer( mico_timer_t* timer, uint32_t time_ms, timer_handler_t function, void* arg );
N
N
N/** @brief    Starts a RTOS timer running
N  *
N  * @note     Timer must have been previously initialised with @ref mico_init_timer
N  *
N  * @param    timer    : a pointer to the timer handle to start
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NWEAK OSStatus mico_start_timer( mico_timer_t* timer );
X__attribute__ ((weak)) OSStatus mico_start_timer( mico_timer_t* timer );
N
N
N/** @brief    Stops a running RTOS timer
N  *
N  * @note     Timer must have been previously started with @ref mico_start_timer
N  *
N  * @param    timer    : a pointer to the timer handle to stop
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NWEAK OSStatus mico_stop_timer( mico_timer_t* timer );
X__attribute__ ((weak)) OSStatus mico_stop_timer( mico_timer_t* timer );
N
N
N/** @brief    Reloads a RTOS timer that has expired
N  *
N  * @note     This is usually called in the timer callback handler, to
N  *           reschedule the timer for the next period.
N  *
N  * @param    timer    : a pointer to the timer handle to reload
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NOSStatus mico_reload_timer( mico_timer_t* timer );
N
N
N/** @brief    De-initialise a RTOS timer
N  *
N  * @note     Deletes a RTOS timer created with @ref mico_init_timer
N  *
N  * @param    timer : a pointer to the RTOS timer handle
N  *
N  * @return   kNoErr        : on success.
N  * @return   kGeneralErr   : if an error occurred
N  */
NOSStatus mico_deinit_timer( mico_timer_t* timer );
N
N
N/** @brief    Check if an RTOS timer is running
N  *
N  * @param    timer : a pointer to the RTOS timer handle
N  *
N  * @return   true        : if running.
N  * @return   false       : if not running
N  */
Nbool mico_is_timer_running( mico_timer_t* timer );
X_Bool mico_is_timer_running( mico_timer_t* timer );
N
N/**
N  * @}
N  */
N
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
L 35 "..\..\..\Platform\Common\Cortex-M3\STM32F2xx\MicoDriverGpio.c" 2
N#include "gpio_irq.h"
L 1 "..\..\..\Platform\Common\Cortex-M3\STM32F2xx\gpio_irq.h" 1
N/**
N******************************************************************************
N* @file    gpio_irq.h 
N* @author  William Xu
N* @version V1.0.0
N* @date    05-May-2014
N* @brief   This file provides all the headers of GPIO external interrupt 
N*          operation functions.
N******************************************************************************
N*
N*  The MIT License
N*  Copyright (c) 2014 MXCHIP Inc.
N*
N*  Permission is hereby granted, free of charge, to any person obtaining a copy 
N*  of this software and associated documentation files (the "Software"), to deal
N*  in the Software without restriction, including without limitation the rights 
N*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N*  copies of the Software, and to permit persons to whom the Software is furnished
N*  to do so, subject to the following conditions:
N*
N*  The above copyright notice and this permission notice shall be included in
N*  all copies or substantial portions of the Software.
N*
N*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
N*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
N*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
N*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N*  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
N*  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N******************************************************************************
N*/ 
N
N#pragma once
N
N#include <stdint.h>
C "..\..\..\Platform\Common\Cortex-M3\STM32F2xx\gpio_irq.h" 36 23 cannot open source input file "stm32f2xx.h": No such file or directory
N#include "stm32f2xx.h"
