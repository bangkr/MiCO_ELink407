; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\..\build\bootloader\emw3162\obj_rvmdk\stringutils.o --asm_dir=..\..\..\Build\Bootloader\EMW3162\List_RVMDK\ --list_dir=..\..\..\Build\Bootloader\EMW3162\List_RVMDK\ --depend=..\..\..\build\bootloader\emw3162\obj_rvmdk\stringutils.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=1,1293 -I..\..\..\include -I..\..\..\Platform\Common\Cortex-M4\CMSIS -I..\..\..\Platform\Common\Cortex-M4\STM32F4xx\STM32F4xx_Drv -I..\..\..\Platform\Common\Cortex-M4\STM32F4xx -I..\..\..\Platform\Common\Cortex-M4 -I..\..\..\Platform\Common\Cortex-M4\STM32F4xx\STM32F4xx_Drv\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\Bootloader -I..\..\..\MICO -I..\..\..\Platform\EMW3162 -I..\..\..\External -I..\..\..\Library\support -I..\..\..\Platform\include -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.1\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\1.0.6\Device\Include -D__MICROLIB -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DBOOTLOADER -DSIZE_OPTIMIZE ..\..\..\Library\support\StringUtils.c]
                          THUMB

                          AREA ||i.DataToCString||, CODE, READONLY, ALIGN=1

                  DataToCString PROC
;;;360    
;;;361    char* DataToCString( const uint8_t *inBuf, size_t inBufLen )
000000  b570              PUSH     {r4-r6,lr}
;;;362    {
000002  460d              MOV      r5,r1
000004  0006              MOVS     r6,r0
000006  d00d              BEQ      |L1.36|
;;;363        char* cString = NULL;
;;;364        require_quiet(inBuf, error);
;;;365        require_quiet(inBufLen > 0, error);
000008  b165              CBZ      r5,|L1.36|
;;;366    
;;;367        cString = (char*) malloc( inBufLen + 1 );
00000a  1c68              ADDS     r0,r5,#1
00000c  f7fffffe          BL       malloc
000010  0004              MOVS     r4,r0
;;;368        require(cString, error);
000012  d007              BEQ      |L1.36|
;;;369        memcpy( cString, inBuf, inBufLen );
000014  462a              MOV      r2,r5
000016  4631              MOV      r1,r6
000018  f7fffffe          BL       __aeabi_memcpy
;;;370        *(cString + inBufLen ) = '\0';
00001c  2000              MOVS     r0,#0
00001e  5560              STRB     r0,[r4,r5]
;;;371        return cString;
000020  4620              MOV      r0,r4
;;;372    
;;;373    error:
;;;374        if ( cString ) free( cString );
;;;375        return NULL;
;;;376    }
000022  bd70              POP      {r4-r6,pc}
                  |L1.36|
000024  2000              MOVS     r0,#0                 ;375
000026  bd70              POP      {r4-r6,pc}
;;;377    
                          ENDP


                          AREA ||i.DataToHexString||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_return_value
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  DataToHexString PROC
;;;294    
;;;295    char* DataToHexString( const uint8_t *inBuf, size_t inBufLen )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;296    {
000004  460e              MOV      r6,r1
000006  ea5f0800          MOVS     r8,r0
00000a  d019              BEQ      |L2.64|
;;;297        char* buf_str = NULL;
;;;298        char* buf_ptr;
;;;299        require_quiet(inBuf, error);
;;;300        require_quiet(inBufLen > 0, error);
00000c  b1c6              CBZ      r6,|L2.64|
;;;301    
;;;302        buf_str = (char*) malloc (2*inBufLen + 1);
00000e  2001              MOVS     r0,#1
000010  eb000046          ADD      r0,r0,r6,LSL #1
000014  f7fffffe          BL       malloc
000018  0007              MOVS     r7,r0
;;;303        require(buf_str, error);
00001a  d011              BEQ      |L2.64|
;;;304        buf_ptr = buf_str;
00001c  4605              MOV      r5,r0
;;;305        uint32_t i;
;;;306        for (i = 0; i < inBufLen; i++) buf_ptr += sprintf(buf_ptr, "%02X", inBuf[i]);
00001e  2400              MOVS     r4,#0
000020  e007              B        |L2.50|
                  |L2.34|
000022  f8182004          LDRB     r2,[r8,r4]
000026  a107              ADR      r1,|L2.68|
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       __2sprintf
00002e  4405              ADD      r5,r5,r0
000030  1c64              ADDS     r4,r4,#1
                  |L2.50|
000032  42b4              CMP      r4,r6
000034  d3f5              BCC      |L2.34|
;;;307        *buf_ptr = '\0';
000036  2000              MOVS     r0,#0
000038  7028              STRB     r0,[r5,#0]
;;;308        return buf_str;
00003a  4638              MOV      r0,r7
                  |L2.60|
;;;309    
;;;310    error:
;;;311        if ( buf_str ) free( buf_str );
;;;312        return NULL;
;;;313    }
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L2.64|
000040  2000              MOVS     r0,#0                 ;312
000042  e7fb              B        |L2.60|
;;;314    
                          ENDP

                  |L2.68|
000044  25303258          DCB      "%02X",0
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.DataToHexStringWithColons||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_return_value
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  DataToHexStringWithColons PROC
;;;334    
;;;335    char* DataToHexStringWithColons( const uint8_t *inBuf, size_t inBufLen )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;336    {
000004  460e              MOV      r6,r1
000006  0007              MOVS     r7,r0
000008  d01f              BEQ      |L3.74|
;;;337        char* buf_str = NULL;
;;;338        char* buf_ptr = NULL;
;;;339        require_quiet(inBuf, error);
;;;340        require_quiet(inBufLen > 0, error);
00000a  b1f6              CBZ      r6,|L3.74|
;;;341    
;;;342        buf_str = (char*) malloc (3*inBufLen + 1);
00000c  eb060046          ADD      r0,r6,r6,LSL #1
000010  1c40              ADDS     r0,r0,#1
000012  f7fffffe          BL       malloc
000016  ea5f0800          MOVS     r8,r0
;;;343        require(buf_str, error);
00001a  d016              BEQ      |L3.74|
;;;344        buf_ptr = buf_str;
00001c  4605              MOV      r5,r0
;;;345        uint32_t i;
;;;346        for (i = 0; i < inBufLen; i++)
00001e  2400              MOVS     r4,#0
;;;347        {
;;;348            if ( i == inBufLen - 1 )
000020  f1a60901          SUB      r9,r6,#1
000024  e00a              B        |L3.60|
                  |L3.38|
;;;349                buf_ptr += sprintf(buf_ptr, "%02X", inBuf[i]);
;;;350            else
;;;351                buf_ptr += sprintf(buf_ptr, "%02X:", inBuf[i]);
000026  5d3a              LDRB     r2,[r7,r4]
000028  454c              CMP      r4,r9                 ;348
00002a  d101              BNE      |L3.48|
00002c  a108              ADR      r1,|L3.80|
00002e  e000              B        |L3.50|
                  |L3.48|
000030  a109              ADR      r1,|L3.88|
                  |L3.50|
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       __2sprintf
000038  4405              ADD      r5,r5,r0
00003a  1c64              ADDS     r4,r4,#1
                  |L3.60|
00003c  42b4              CMP      r4,r6                 ;346
00003e  d3f2              BCC      |L3.38|
;;;352        }
;;;353        *buf_ptr = '\0';
000040  2000              MOVS     r0,#0
000042  7028              STRB     r0,[r5,#0]
;;;354        return buf_str;
000044  4640              MOV      r0,r8
                  |L3.70|
;;;355    
;;;356    error:
;;;357        if ( buf_str ) free( buf_str );
;;;358        return NULL;
;;;359    }
000046  e8bd87f0          POP      {r4-r10,pc}
                  |L3.74|
00004a  2000              MOVS     r0,#0                 ;358
00004c  e7fb              B        |L3.70|
;;;360    
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
000050  25303258          DCB      "%02X",0
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0
                  |L3.88|
000058  25303258          DCB      "%02X:",0
00005c  3a00    
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.DataToHexStringWithSpaces||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_return_value
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  DataToHexStringWithSpaces PROC
;;;314    
;;;315    char* DataToHexStringWithSpaces( const uint8_t *inBuf, size_t inBufLen )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;316    {
000004  460e              MOV      r6,r1
000006  ea5f0800          MOVS     r8,r0
00000a  d019              BEQ      |L4.64|
;;;317        char* buf_str = NULL;
;;;318        char* buf_ptr = NULL;
;;;319        require_quiet(inBuf, error);
;;;320        require_quiet(inBufLen > 0, error);
00000c  b1c6              CBZ      r6,|L4.64|
;;;321    
;;;322        buf_str = (char*) malloc (3*inBufLen + 1);
00000e  eb060046          ADD      r0,r6,r6,LSL #1
000012  1c40              ADDS     r0,r0,#1
000014  f7fffffe          BL       malloc
000018  0007              MOVS     r7,r0
;;;323        require(buf_str, error);
00001a  d011              BEQ      |L4.64|
;;;324        buf_ptr = buf_str;
00001c  4605              MOV      r5,r0
;;;325        uint32_t i;
;;;326        for (i = 0; i < inBufLen; i++) buf_ptr += sprintf(buf_ptr, "%02X ", inBuf[i]);
00001e  2400              MOVS     r4,#0
000020  e007              B        |L4.50|
                  |L4.34|
000022  f8182004          LDRB     r2,[r8,r4]
000026  a107              ADR      r1,|L4.68|
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       __2sprintf
00002e  4405              ADD      r5,r5,r0
000030  1c64              ADDS     r4,r4,#1
                  |L4.50|
000032  42b4              CMP      r4,r6
000034  d3f5              BCC      |L4.34|
;;;327        *buf_ptr = '\0';
000036  2000              MOVS     r0,#0
000038  7028              STRB     r0,[r5,#0]
;;;328        return buf_str;
00003a  4638              MOV      r0,r7
                  |L4.60|
;;;329    
;;;330    error:
;;;331        if ( buf_str ) free( buf_str );
;;;332        return NULL;
;;;333    }
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L4.64|
000040  2000              MOVS     r0,#0                 ;332
000042  e7fb              B        |L4.60|
;;;334    
                          ENDP

                  |L4.68|
000044  25303258          DCB      "%02X ",0
000048  2000    
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.Int2Str||, CODE, READONLY, ALIGN=2

                  Int2Str PROC
;;;142    
;;;143    void Int2Str(uint8_t* str, int32_t intnum)
000000  b5f0              PUSH     {r4-r7,lr}
;;;144    {
;;;145      uint32_t i, Div = 1000000000, j = 0, Status = 0;
000002  2200              MOVS     r2,#0
000004  4b0d              LDR      r3,|L5.60|
000006  4614              MOV      r4,r2
;;;146    
;;;147      for (i = 0; i < 10; i++)
000008  4615              MOV      r5,r2
;;;148      {
;;;149        str[j++] = (intnum / Div) + 48;
;;;150    
;;;151        intnum = intnum % Div;
;;;152        Div /= 10;
00000a  f04f0c0a          MOV      r12,#0xa
                  |L5.14|
00000e  fbb1f6f3          UDIV     r6,r1,r3              ;149
000012  fb031116          MLS      r1,r3,r6,r1           ;151
000016  f1060730          ADD      r7,r6,#0x30           ;149
00001a  5487              STRB     r7,[r0,r2]            ;149
00001c  fbb3f3fc          UDIV     r3,r3,r12
000020  1c52              ADDS     r2,r2,#1
;;;153        if ((str[j-1] == '0') & (Status == 0))
000022  1886              ADDS     r6,r0,r2
000024  f8166c01          LDRB     r6,[r6,#-1]
000028  2e30              CMP      r6,#0x30
00002a  d100              BNE      |L5.46|
00002c  b124              CBZ      r4,|L5.56|
                  |L5.46|
00002e  1c64              ADDS     r4,r4,#1
                  |L5.48|
000030  1c6d              ADDS     r5,r5,#1
000032  2d0a              CMP      r5,#0xa               ;147
000034  d3eb              BCC      |L5.14|
;;;154        {
;;;155          j = 0;
;;;156        }
;;;157        else
;;;158        {
;;;159          Status++;
;;;160        }
;;;161      }
;;;162    }
000036  bdf0              POP      {r4-r7,pc}
                  |L5.56|
000038  2200              MOVS     r2,#0                 ;155
00003a  e7f9              B        |L5.48|
;;;163    
                          ENDP

                  |L5.60|
                          DCD      0x3b9aca00

                          AREA ||i.Str2Int||, CODE, READONLY, ALIGN=1

                  Str2Int PROC
;;;163    
;;;164    uint32_t Str2Int(uint8_t *inputstr, int32_t *intnum)
000000  b570              PUSH     {r4-r6,lr}
;;;165    {
;;;166      uint32_t i = 0, res = 0;
000002  2300              MOVS     r3,#0
;;;167      uint32_t val = 0;
;;;168    
;;;169      if (inputstr[0] == '0' && (inputstr[1] == 'x' || inputstr[1] == 'X'))
000004  7802              LDRB     r2,[r0,#0]
000006  461c              MOV      r4,r3                 ;167
000008  2a30              CMP      r2,#0x30
00000a  d104              BNE      |L6.22|
00000c  7842              LDRB     r2,[r0,#1]
00000e  2a78              CMP      r2,#0x78
000010  d00a              BEQ      |L6.40|
000012  2a58              CMP      r2,#0x58
000014  d008              BEQ      |L6.40|
                  |L6.22|
;;;170      {
;;;171        if (inputstr[2] == '\0')
;;;172        {
;;;173          return 0;
;;;174        }
;;;175        for (i = 2; i < 11; i++)
;;;176        {
;;;177          if (inputstr[i] == '\0')
;;;178          {
;;;179            *intnum = val;
;;;180            /* return 1; */
;;;181            res = 1;
;;;182            break;
;;;183          }
;;;184          if (ISVALIDHEX(inputstr[i]))
;;;185          {
;;;186            val = (val << 4) + CONVERTHEX(inputstr[i]);
;;;187          }
;;;188          else
;;;189          {
;;;190            /* Return 0, Invalid input */
;;;191            res = 0;
;;;192            break;
;;;193          }
;;;194        }
;;;195        /* Over 8 digit hex --invalid */
;;;196        if (i >= 11)
;;;197        {
;;;198          res = 0;
;;;199        }
;;;200      }
;;;201      else /* max 10-digit decimal input */
;;;202      {
;;;203        for (i = 0;i < 11;i++)
;;;204        {
;;;205          if (inputstr[i] == '\0')
;;;206          {
;;;207            *intnum = val;
;;;208            /* return 1 */
;;;209            res = 1;
;;;210            break;
;;;211          }
;;;212          else if ((inputstr[i] == 'k' || inputstr[i] == 'K') && (i > 0))
;;;213          {
;;;214            val = val << 10;
;;;215            *intnum = val;
;;;216            res = 1;
;;;217            break;
;;;218          }
;;;219          else if ((inputstr[i] == 'm' || inputstr[i] == 'M') && (i > 0))
;;;220          {
;;;221            val = val << 20;
;;;222            *intnum = val;
;;;223            res = 1;
;;;224            break;
;;;225          }
;;;226          else if (ISVALIDDEC(inputstr[i]))
;;;227          {
;;;228            val = val * 10 + CONVERTDEC(inputstr[i]);
000016  f06f052f          MVN      r5,#0x2f
                  |L6.26|
00001a  5cc2              LDRB     r2,[r0,r3]            ;205
00001c  b1aa              CBZ      r2,|L6.74|
00001e  2a6b              CMP      r2,#0x6b              ;212
000020  d02a              BEQ      |L6.120|
000022  2a4b              CMP      r2,#0x4b              ;212
000024  d028              BEQ      |L6.120|
000026  e02c              B        |L6.130|
                  |L6.40|
000028  7882              LDRB     r2,[r0,#2]            ;171
00002a  b302              CBZ      r2,|L6.110|
00002c  2302              MOVS     r3,#2                 ;175
                  |L6.46|
00002e  5cc2              LDRB     r2,[r0,r3]            ;177
000030  b15a              CBZ      r2,|L6.74|
000032  f1a20541          SUB      r5,r2,#0x41           ;184
000036  2d05              CMP      r5,#5                 ;184
000038  d909              BLS      |L6.78|
00003a  f1a20661          SUB      r6,r2,#0x61           ;184
00003e  2e05              CMP      r6,#5                 ;184
000040  d905              BLS      |L6.78|
000042  3511              ADDS     r5,r5,#0x11           ;184
000044  2d09              CMP      r5,#9                 ;184
000046  d906              BLS      |L6.86|
000048  e030              B        |L6.172|
                  |L6.74|
00004a  600c              STR      r4,[r1,#0]            ;182
00004c  e017              B        |L6.126|
                  |L6.78|
00004e  f1a20630          SUB      r6,r2,#0x30           ;186
000052  2e09              CMP      r6,#9                 ;186
000054  d801              BHI      |L6.90|
                  |L6.86|
000056  3a30              SUBS     r2,r2,#0x30           ;186
000058  e004              B        |L6.100|
                  |L6.90|
00005a  2d05              CMP      r5,#5                 ;186
00005c  d801              BHI      |L6.98|
00005e  3a37              SUBS     r2,r2,#0x37           ;186
000060  e000              B        |L6.100|
                  |L6.98|
000062  3a57              SUBS     r2,r2,#0x57           ;186
                  |L6.100|
000064  1c5b              ADDS     r3,r3,#1              ;186
000066  eb021404          ADD      r4,r2,r4,LSL #4       ;186
00006a  2b0b              CMP      r3,#0xb               ;175
00006c  d3df              BCC      |L6.46|
                  |L6.110|
00006e  e001              B        |L6.116|
                  |L6.112|
000070  2b0b              CMP      r3,#0xb               ;196
000072  d300              BCC      |L6.118|
                  |L6.116|
000074  2000              MOVS     r0,#0                 ;198
                  |L6.118|
;;;229          }
;;;230          else
;;;231          {
;;;232            /* return 0, Invalid input */
;;;233            res = 0;
;;;234            break;
;;;235          }
;;;236        }
;;;237        /* Over 10 digit decimal --invalid */
;;;238        if (i >= 11)
;;;239        {
;;;240          res = 0;
;;;241        }
;;;242      }
;;;243    
;;;244      return res;
;;;245    }
000076  bd70              POP      {r4-r6,pc}
                  |L6.120|
000078  b11b              CBZ      r3,|L6.130|
00007a  02a0              LSLS     r0,r4,#10             ;214
00007c  e007              B        |L6.142|
                  |L6.126|
00007e  2001              MOVS     r0,#1                 ;209
000080  e7f6              B        |L6.112|
                  |L6.130|
000082  2a6d              CMP      r2,#0x6d              ;219
000084  d001              BEQ      |L6.138|
000086  2a4d              CMP      r2,#0x4d              ;219
000088  d103              BNE      |L6.146|
                  |L6.138|
00008a  b113              CBZ      r3,|L6.146|
00008c  0520              LSLS     r0,r4,#20             ;221
                  |L6.142|
00008e  6008              STR      r0,[r1,#0]            ;222
000090  e7f5              B        |L6.126|
                  |L6.146|
000092  f1a20630          SUB      r6,r2,#0x30           ;226
000096  2e09              CMP      r6,#9                 ;226
000098  d808              BHI      |L6.172|
00009a  eb040484          ADD      r4,r4,r4,LSL #2       ;228
00009e  eb050444          ADD      r4,r5,r4,LSL #1       ;228
0000a2  1c5b              ADDS     r3,r3,#1              ;228
0000a4  4414              ADD      r4,r4,r2              ;228
0000a6  2b0b              CMP      r3,#0xb               ;203
0000a8  d3b7              BCC      |L6.26|
0000aa  e7e3              B        |L6.116|
                  |L6.172|
0000ac  2000              MOVS     r0,#0                 ;233
0000ae  e7df              B        |L6.112|
;;;246    
                          ENDP


                          AREA ||i.TextToHardwareAddress||, CODE, READONLY, ALIGN=2

                  TextToHardwareAddress PROC
;;;254    
;;;255    OSStatus TextToHardwareAddress( const void *inText, size_t inTextSize, size_t inAddrSize, void *outAddr )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;256    {
000004  4607              MOV      r7,r0
000006  461c              MOV      r4,r3
000008  4691              MOV      r9,r2
;;;257        OSStatus            err;
;;;258        const char *        src;
;;;259        const char *        end;
;;;260        int                 i;
;;;261        int                 x;
;;;262        char                c;
;;;263        uint8_t *           dst;
;;;264    
;;;265        if( inTextSize == kSizeCString ) inTextSize = strlen( (const char *) inText );
00000a  1c48              ADDS     r0,r1,#1
00000c  d103              BNE      |L7.22|
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       strlen
000014  4601              MOV      r1,r0
                  |L7.22|
;;;266        src = (const char *) inText;
;;;267        end = src + inTextSize;
000016  eb070a01          ADD      r10,r7,r1
;;;268        dst = (uint8_t *) outAddr;
00001a  46a0              MOV      r8,r4
;;;269    
;;;270        while( inAddrSize-- > 0 )
00001c  e034              B        |L7.136|
                  |L7.30|
;;;271        {
;;;272            x = 0;
00001e  2500              MOVS     r5,#0
;;;273            i = 0;
000020  462c              MOV      r4,r5
;;;274            while( ( i < 2 ) && ( src < end ) )
000022  e019              B        |L7.88|
                  |L7.36|
;;;275            {
;;;276                c = *src++;
000024  f8176b01          LDRB     r6,[r7],#1
;;;277                if(      isdigit_safe(  c ) ) { x = ( x * 16 )      +               ( c   - '0' ); ++i; }
000028  f7fffffe          BL       __rt_ctype_table
00002c  6800              LDR      r0,[r0,#0]
00002e  5d80              LDRB     r0,[r0,r6]
000030  2820              CMP      r0,#0x20
000032  d00b              BEQ      |L7.76|
000034  ea800080          EOR      r0,r0,r0,LSL #2
;;;278                else if( isxdigit_safe( c ) ) { x = ( x * 16 ) + 10 + ( tolower_safe( c ) - 'a' ); ++i; }
000038  0600              LSLS     r0,r0,#24
00003a  d511              BPL      |L7.96|
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       tolower
000042  eb001505          ADD      r5,r0,r5,LSL #4
000046  1c64              ADDS     r4,r4,#1
000048  3d57              SUBS     r5,r5,#0x57
00004a  e003              B        |L7.84|
                  |L7.76|
00004c  eb061505          ADD      r5,r6,r5,LSL #4       ;277
000050  1c64              ADDS     r4,r4,#1              ;277
000052  3d30              SUBS     r5,r5,#0x30           ;277
                  |L7.84|
000054  2c02              CMP      r4,#2                 ;274
000056  da04              BGE      |L7.98|
                  |L7.88|
000058  4557              CMP      r7,r10                ;274
00005a  d3e3              BCC      |L7.36|
;;;279                else if( ( i != 0 ) || ( ( c != ':' ) && ( c != '-' ) && ( c != ' ' ) ) ) break;
;;;280            }
;;;281            if( i == 0 )
00005c  b164              CBZ      r4,|L7.120|
00005e  e000              B        |L7.98|
                  |L7.96|
000060  b124              CBZ      r4,|L7.108|
                  |L7.98|
;;;282            {
;;;283                err = kMalformedErr;
;;;284                goto exit;
;;;285            }
;;;286            require_action( (( x >= 0x00 ) && ( x <= 0xFF )), exit, err = kRangeErr );
000062  2dff              CMP      r5,#0xff
000064  d90b              BLS      |L7.126|
000066  480b              LDR      r0,|L7.148|
                  |L7.104|
;;;287            if( dst ) *dst++ = (uint8_t) x;
;;;288        }
;;;289        err = kNoErr;
;;;290    
;;;291    exit:
;;;292        return err;
;;;293    }
000068  e8bd87f0          POP      {r4-r10,pc}
                  |L7.108|
00006c  2e3a              CMP      r6,#0x3a              ;279
00006e  d0f3              BEQ      |L7.88|
000070  2e2d              CMP      r6,#0x2d              ;279
000072  d0f1              BEQ      |L7.88|
000074  2e20              CMP      r6,#0x20              ;279
000076  d0ef              BEQ      |L7.88|
                  |L7.120|
000078  4806              LDR      r0,|L7.148|
00007a  3820              SUBS     r0,r0,#0x20           ;283
00007c  e7f4              B        |L7.104|
                  |L7.126|
00007e  f1b80f00          CMP      r8,#0                 ;287
000082  d001              BEQ      |L7.136|
000084  f8085b01          STRB     r5,[r8],#1            ;287
                  |L7.136|
000088  f1a90901          SUB      r9,r9,#1              ;270
00008c  f1190001          ADDS     r0,r9,#1              ;270
000090  d1c5              BNE      |L7.30|
000092  e7e9              B        |L7.104|
;;;294    
                          ENDP

                  |L7.148|
                          DCD      0xffffe5ca

                          AREA ||i.VSNScanF||, CODE, READONLY, ALIGN=1

                  VSNScanF PROC
;;;438    
;;;439    int VSNScanF( const void *inString, size_t inSize, const char *inFormat, va_list inArgs )
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;440    {
000004  b087              SUB      sp,sp,#0x1c
000006  4699              MOV      r9,r3
000008  4616              MOV      r6,r2
;;;441        int                         matched;
;;;442        const unsigned char *       src;
;;;443        const unsigned char *       end;
;;;444        const unsigned char *       fmt;
;;;445        const unsigned char *       old;
;;;446        const unsigned char *       setStart;
;;;447        const unsigned char *       setEnd;
;;;448        const unsigned char *       set;
;;;449        int                         notSet;
;;;450        int                         suppress;
;;;451        int                         alt;
;;;452        int                         storePtr;
;;;453        int                         fieldWidth;
;;;454        int                         sizeModifier;
;;;455        unsigned char *             s;
;;;456        int *                       i;
;;;457        int                         base;
;;;458        int                         negative;
;;;459        unsigned char               c;
;;;460        int64_t                     x;
;;;461        int                         v;
;;;462        void *                      p;
;;;463        const unsigned char **      ptrArg;
;;;464        size_t *                    sizeArg;
;;;465        size_t                      len;
;;;466    
;;;467        if( inSize == kSizeCString ) inSize = strlen( (const char *) inString );
00000a  1c48              ADDS     r0,r1,#1
00000c  d103              BNE      |L8.22|
00000e  9807              LDR      r0,[sp,#0x1c]
000010  f7fffffe          BL       strlen
000014  4601              MOV      r1,r0
                  |L8.22|
;;;468        src = (const unsigned char *) inString;
;;;469        end = src + inSize;
000016  9c07              LDR      r4,[sp,#0x1c]
;;;470        fmt = (const unsigned char *) inFormat;
;;;471    
;;;472        matched = 0;
000018  2000              MOVS     r0,#0
00001a  1867              ADDS     r7,r4,r1              ;469
;;;473        for( ;; )
;;;474        {
;;;475            // Skip whitespace. 1 or more whitespace in the format matches 0 or more whitepsace in the string.
;;;476    
;;;477            if( isspace( *fmt ) )
00001c  9000              STR      r0,[sp,#0]
00001e  f7fffffe          BL       __rt_ctype_table
000022  9003              STR      r0,[sp,#0xc]
                  |L8.36|
000024  9803              LDR      r0,[sp,#0xc]
000026  7831              LDRB     r1,[r6,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  5c41              LDRB     r1,[r0,r1]
00002c  07c9              LSLS     r1,r1,#31
00002e  d00c              BEQ      |L8.74|
                  |L8.48|
;;;478            {
;;;479                ++fmt;
;;;480                while( isspace( *fmt ) )                  ++fmt;
000030  f8161f01          LDRB     r1,[r6,#1]!
000034  5c41              LDRB     r1,[r0,r1]
000036  07c9              LSLS     r1,r1,#31
000038  d1fa              BNE      |L8.48|
00003a  e000              B        |L8.62|
                  |L8.60|
00003c  1c64              ADDS     r4,r4,#1
                  |L8.62|
;;;481                while( ( src < end ) && isspace( *src ) ) ++src;
00003e  42bc              CMP      r4,r7
000040  d203              BCS      |L8.74|
000042  7821              LDRB     r1,[r4,#0]
000044  5c41              LDRB     r1,[r0,r1]
000046  07c9              LSLS     r1,r1,#31
000048  d1f8              BNE      |L8.60|
                  |L8.74|
;;;482            }
;;;483            if( *fmt == '\0' ) break;
00004a  7831              LDRB     r1,[r6,#0]
00004c  2900              CMP      r1,#0
00004e  d008              BEQ      |L8.98|
;;;484    
;;;485            // If it's not a conversion, it must match exactly. Otherwise, move onto conversion handling.
;;;486    
;;;487            if( *fmt != '%' )
000050  2925              CMP      r1,#0x25
000052  d007              BEQ      |L8.100|
;;;488            {
;;;489                if( src >= end )        break;
000054  42bc              CMP      r4,r7
000056  d204              BCS      |L8.98|
;;;490                if( *fmt++ != *src++ )  break;
000058  f8140b01          LDRB     r0,[r4],#1
00005c  1c76              ADDS     r6,r6,#1
00005e  4281              CMP      r1,r0
000060  d0e0              BEQ      |L8.36|
                  |L8.98|
000062  e27f              B        |L8.1380|
                  |L8.100|
;;;491                continue;
;;;492            }
;;;493            ++fmt;
;;;494    
;;;495            // Flags
;;;496    
;;;497            suppress = 0;
000064  2100              MOVS     r1,#0
;;;498            alt      = 0;
000066  460a              MOV      r2,r1
;;;499            storePtr = 0;
;;;500            for( ;; )
000068  9101              STR      r1,[sp,#4]
00006a  e01a              B        |L8.162|
                  |L8.108|
;;;501            {
;;;502                c = *fmt;
;;;503                if(      c == '*' ) suppress = 1;
00006c  2101              MOVS     r1,#1
00006e  9101              STR      r1,[sp,#4]
000070  e018              B        |L8.164|
                  |L8.114|
;;;504                else if( c == '#' ) alt     += 1;
000072  2923              CMP      r1,#0x23
000074  d012              BEQ      |L8.156|
;;;505                else if( c == '&' ) storePtr = 1;
000076  2926              CMP      r1,#0x26
000078  d012              BEQ      |L8.160|
;;;506                else break;
;;;507                ++fmt;
;;;508            }
;;;509    
;;;510            // Field width. If none, use INT_MAX to simplify no-width vs width cases.
;;;511    
;;;512            if( isdigit( *fmt ) )
00007a  b2c9              UXTB     r1,r1
00007c  5c43              LDRB     r3,[r0,r1]
00007e  2b20              CMP      r3,#0x20
000080  d015              BEQ      |L8.174|
;;;513            {
;;;514                fieldWidth = 0;
;;;515                do
;;;516                {
;;;517                    fieldWidth = ( fieldWidth * 10 ) + ( *fmt++ - '0' );
;;;518    
;;;519                }   while( isdigit( *fmt ) );
;;;520            }
;;;521            else if( *fmt == '.' )
000082  292e              CMP      r1,#0x2e
000084  d022              BEQ      |L8.204|
;;;522            {
;;;523                ++fmt;
;;;524                fieldWidth = va_arg( inArgs, int );
;;;525                if( fieldWidth < 0 ) goto exit;
;;;526            }
;;;527            else
;;;528            {
;;;529                fieldWidth = INT_MAX;
000086  f06f4500          MVN      r5,#0x80000000
                  |L8.138|
;;;530            }
;;;531    
;;;532            // Size modifier. Note: converts double-char (e.g. hh) into unique char (e.g. H) for easier processing.
;;;533    
;;;534            c = *fmt;
00008a  7831              LDRB     r1,[r6,#0]
;;;535            switch( c )
00008c  296c              CMP      r1,#0x6c
00008e  d031              BEQ      |L8.244|
000090  dc22              BGT      |L8.216|
000092  2968              CMP      r1,#0x68
000094  d026              BEQ      |L8.228|
000096  296a              CMP      r1,#0x6a
000098  d122              BNE      |L8.224|
00009a  e033              B        |L8.260|
                  |L8.156|
00009c  1c52              ADDS     r2,r2,#1
00009e  e001              B        |L8.164|
                  |L8.160|
0000a0  2101              MOVS     r1,#1                 ;505
                  |L8.162|
0000a2  468a              MOV      r10,r1                ;499
                  |L8.164|
0000a4  f8161f01          LDRB     r1,[r6,#1]!           ;502
0000a8  292a              CMP      r1,#0x2a              ;503
0000aa  d1e2              BNE      |L8.114|
0000ac  e7de              B        |L8.108|
                  |L8.174|
0000ae  2500              MOVS     r5,#0                 ;514
0000b0  f06f012f          MVN      r1,#0x2f              ;517
                  |L8.180|
0000b4  f8163b01          LDRB     r3,[r6],#1            ;517
0000b8  eb050585          ADD      r5,r5,r5,LSL #2       ;517
0000bc  eb010545          ADD      r5,r1,r5,LSL #1       ;517
0000c0  441d              ADD      r5,r5,r3              ;517
0000c2  7833              LDRB     r3,[r6,#0]            ;519
0000c4  5cc3              LDRB     r3,[r0,r3]            ;519
0000c6  2b20              CMP      r3,#0x20              ;519
0000c8  d0f4              BEQ      |L8.180|
0000ca  e7de              B        |L8.138|
                  |L8.204|
0000cc  f8595b04          LDR      r5,[r9],#4            ;524
0000d0  1c76              ADDS     r6,r6,#1              ;524
0000d2  2d00              CMP      r5,#0                 ;525
                  |L8.212|
0000d4  dbc5              BLT      |L8.98|
0000d6  e7d8              B        |L8.138|
                  |L8.216|
0000d8  2974              CMP      r1,#0x74
0000da  d013              BEQ      |L8.260|
0000dc  297a              CMP      r1,#0x7a
0000de  d011              BEQ      |L8.260|
                  |L8.224|
;;;536            {
;;;537                case 'h':
;;;538                    if( *( ++fmt ) == 'h' ) { sizeModifier = 'H'; ++fmt; }  // hh for char * / unsigned char *
;;;539                    else                      sizeModifier = 'h';           // h  for short * / unsigned short *
;;;540                    break;
;;;541    
;;;542                case 'l':
;;;543                    if( *( ++fmt ) == 'l' ) { sizeModifier = 'L'; ++fmt; }  // ll for long long * / unsigned long long *
;;;544                    else                      sizeModifier = 'l';           // l  for long * / unsigned long *
;;;545                    break;
;;;546    
;;;547                case 'j':   // j for intmax_t * / uintmax_t *
;;;548                case 'z':   // z for size_t *
;;;549                case 't':   // t for ptrdiff_t *
;;;550                    sizeModifier = c;
;;;551                    ++fmt;
;;;552                    break;
;;;553    
;;;554                default:
;;;555                    sizeModifier = 0;
0000e0  2100              MOVS     r1,#0
;;;556                    break;
0000e2  e00c              B        |L8.254|
                  |L8.228|
0000e4  f8161f01          LDRB     r1,[r6,#1]!           ;538
0000e8  2968              CMP      r1,#0x68              ;538
0000ea  d001              BEQ      |L8.240|
0000ec  2168              MOVS     r1,#0x68              ;539
0000ee  e006              B        |L8.254|
                  |L8.240|
0000f0  2148              MOVS     r1,#0x48              ;538
0000f2  e007              B        |L8.260|
                  |L8.244|
0000f4  f8161f01          LDRB     r1,[r6,#1]!           ;543
0000f8  296c              CMP      r1,#0x6c              ;543
0000fa  d002              BEQ      |L8.258|
0000fc  216c              MOVS     r1,#0x6c              ;544
                  |L8.254|
0000fe  468b              MOV      r11,r1                ;544
000100  e002              B        |L8.264|
                  |L8.258|
000102  214c              MOVS     r1,#0x4c              ;543
                  |L8.260|
000104  468b              MOV      r11,r1                ;543
000106  1c76              ADDS     r6,r6,#1              ;543
                  |L8.264|
;;;557            }
;;;558            if( *fmt == '\0' ) break;
000108  7831              LDRB     r1,[r6,#0]
00010a  2900              CMP      r1,#0
                  |L8.268|
00010c  d0a9              BEQ      |L8.98|
00010e  1c76              ADDS     r6,r6,#1
;;;559    
;;;560            // Conversions
;;;561    
;;;562            switch( *fmt++ )
000110  2969              CMP      r1,#0x69
000112  d025              BEQ      |L8.352|
000114  dc0e              BGT      |L8.308|
000116  2962              CMP      r1,#0x62
000118  d024              BEQ      |L8.356|
00011a  dc06              BGT      |L8.298|
00011c  2925              CMP      r1,#0x25
00011e  d07a              BEQ      |L8.534|
000120  2958              CMP      r1,#0x58
000122  d019              BEQ      |L8.344|
000124  295b              CMP      r1,#0x5b
                  |L8.294|
000126  d19c              BNE      |L8.98|
000128  e0ac              B        |L8.644|
                  |L8.298|
00012a  2963              CMP      r1,#0x63
00012c  d01d              BEQ      |L8.362|
00012e  2964              CMP      r1,#0x64
000130  d197              BNE      |L8.98|
000132  e00a              B        |L8.330|
                  |L8.308|
000134  396e              SUBS     r1,r1,#0x6e
000136  290b              CMP      r1,#0xb
                  |L8.312|
000138  d293              BCS      |L8.98|
00013a  e8dff001          TBB      [pc,r1]
00013e  fd0f              DCB      0xfd,0x0f
000140  08fcfc4a          DCB      0x08,0xfc,0xfc,0x4a
000144  fc06fcfc          DCB      0xfc,0x06,0xfc,0xfc
000148  0d00              DCB      0x0d,0x00
                  |L8.330|
;;;563            {
;;;564                case 'd':   // %d: Signed decimal integer.
;;;565                    base = 10;
00014a  210a              MOVS     r1,#0xa
;;;566                    break;
00014c  e00b              B        |L8.358|
;;;567    
;;;568                case 'u':   // %u: Unsigned decimal integer.
;;;569                    base = 10;
;;;570                    break;
;;;571    
;;;572                case 'p':   // %x/%X/%p: Hexidecimal integer.
;;;573                    if( sizeModifier == 0 ) sizeModifier = 'p';
00014e  f1bb0f00          CMP      r11,#0
000152  d101              BNE      |L8.344|
000154  f04f0b70          MOV      r11,#0x70
                  |L8.344|
;;;574                case 'x':
;;;575                case 'X':
;;;576                    base = 16;
000158  2110              MOVS     r1,#0x10
;;;577                    break;
00015a  e004              B        |L8.358|
;;;578    
;;;579                case 'o':   // %o: Octal integer.
;;;580                    base = 8;
00015c  2108              MOVS     r1,#8
;;;581                    break;
00015e  e002              B        |L8.358|
                  |L8.352|
;;;582    
;;;583                case 'i':   // %i: Integer using an optional prefix to determine the base (e.g. 10, 0xA, 012, 0b1010 for decimal 10).
;;;584                    base = 0;
000160  2100              MOVS     r1,#0
;;;585                    break;
000162  e000              B        |L8.358|
                  |L8.356|
;;;586    
;;;587                case 'b':   // %b: Binary integer.
;;;588                    base = 2;
000164  2102              MOVS     r1,#2
                  |L8.358|
000166  468a              MOV      r10,r1
000168  e129              B        |L8.958|
                  |L8.362|
;;;589                    break;
;;;590    
;;;591                case 'c':   // %c: 1 or more characters.
;;;592    
;;;593                    if( sizeModifier != 0 ) goto exit;
00016a  f1bb0f00          CMP      r11,#0
00016e  d1da              BNE      |L8.294|
;;;594                    if( storePtr )
000170  f1ba0f00          CMP      r10,#0
000174  d013              BEQ      |L8.414|
;;;595                    {
;;;596                        len = (size_t)( end - src );
000176  1b38              SUBS     r0,r7,r4
;;;597                        if( len > (size_t) fieldWidth )
000178  42a8              CMP      r0,r5
00017a  d900              BLS      |L8.382|
;;;598                        {
;;;599                            len = (size_t) fieldWidth;
00017c  4628              MOV      r0,r5
                  |L8.382|
;;;600                        }
;;;601                        if( suppress ) { src += len; continue; }
00017e  9901              LDR      r1,[sp,#4]
000180  b109              CBZ      r1,|L8.390|
000182  4404              ADD      r4,r4,r0
                  |L8.388|
000184  e74e              B        |L8.36|
                  |L8.390|
;;;602    
;;;603                        ptrArg = va_arg( inArgs, const unsigned char ** );
;;;604                        if( ptrArg ) *ptrArg = src;
000186  f8d92000          LDR      r2,[r9,#0]
00018a  f1090104          ADD      r1,r9,#4              ;603
00018e  b102              CBZ      r2,|L8.402|
000190  6014              STR      r4,[r2,#0]
                  |L8.402|
;;;605    
;;;606                        sizeArg = va_arg( inArgs, size_t * );
000192  c904              LDM      r1!,{r2}
000194  4689              MOV      r9,r1
;;;607                        if( sizeArg ) *sizeArg = len;
000196  b102              CBZ      r2,|L8.410|
000198  6010              STR      r0,[r2,#0]
                  |L8.410|
;;;608    
;;;609                        src += len;
00019a  4404              ADD      r4,r4,r0
                  |L8.412|
00019c  e1f2              B        |L8.1412|
                  |L8.414|
;;;610                    }
;;;611                    else
;;;612                    {
;;;613                        if( fieldWidth == INT_MAX )         fieldWidth = 1;
00019e  f06f4000          MVN      r0,#0x80000000
0001a2  4285              CMP      r5,r0
0001a4  d100              BNE      |L8.424|
0001a6  2501              MOVS     r5,#1
                  |L8.424|
;;;614                        if( ( end - src ) < fieldWidth )    goto exit;
0001a8  1b38              SUBS     r0,r7,r4
0001aa  42a8              CMP      r0,r5
0001ac  db92              BLT      |L8.212|
;;;615                        if( suppress )                      { src += fieldWidth; continue; }
0001ae  9801              LDR      r0,[sp,#4]
0001b0  b108              CBZ      r0,|L8.438|
0001b2  442c              ADD      r4,r4,r5
0001b4  e736              B        |L8.36|
                  |L8.438|
;;;616    
;;;617                        s = va_arg( inArgs, unsigned char * );
0001b6  f8590b04          LDR      r0,[r9],#4
;;;618                        if( !s ) goto exit;
0001ba  2800              CMP      r0,#0
                  |L8.444|
0001bc  d0a6              BEQ      |L8.268|
0001be  e003              B        |L8.456|
                  |L8.448|
;;;619    
;;;620                        while( fieldWidth-- > 0 ) *s++ = *src++;
0001c0  f8141b01          LDRB     r1,[r4],#1
0001c4  f8001b01          STRB     r1,[r0],#1
                  |L8.456|
0001c8  1e29              SUBS     r1,r5,#0
0001ca  f1a50501          SUB      r5,r5,#1
0001ce  dcf7              BGT      |L8.448|
0001d0  e1d8              B        |L8.1412|
;;;621                    }
;;;622                    ++matched;
;;;623                    continue;
;;;624    
;;;625                case 's':   // %s: string of non-whitespace characters with a null terminator.
;;;626    
;;;627                    if( sizeModifier != 0 ) goto exit;
0001d2  f1bb0f00          CMP      r11,#0
                  |L8.470|
0001d6  d1a6              BNE      |L8.294|
0001d8  e000              B        |L8.476|
                  |L8.474|
0001da  1c64              ADDS     r4,r4,#1
                  |L8.476|
;;;628    
;;;629                    // Skip leading white space first since fieldWidth does not include leading whitespace.
;;;630    
;;;631                    while( ( src < end ) && isspace( *src ) ) ++src;
0001dc  42bc              CMP      r4,r7
0001de  d203              BCS      |L8.488|
0001e0  7821              LDRB     r1,[r4,#0]
0001e2  5c41              LDRB     r1,[r0,r1]
0001e4  07c9              LSLS     r1,r1,#31
0001e6  d1f8              BNE      |L8.474|
                  |L8.488|
;;;632                    if( !alt && ( ( src >= end ) || ( *src == '\0' ) ) ) goto exit;
0001e8  b922              CBNZ     r2,|L8.500|
0001ea  42bc              CMP      r4,r7
0001ec  d2a4              BCS      |L8.312|
0001ee  7821              LDRB     r1,[r4,#0]
0001f0  2900              CMP      r1,#0
0001f2  d08b              BEQ      |L8.268|
                  |L8.500|
;;;633    
;;;634                    // Copy the string until a null terminator, whitespace, or the max fieldWidth is hit.
;;;635    
;;;636                    if( suppress )
0001f4  9901              LDR      r1,[sp,#4]
0001f6  b909              CBNZ     r1,|L8.508|
0001f8  e00e              B        |L8.536|
                  |L8.506|
0001fa  1c64              ADDS     r4,r4,#1
                  |L8.508|
;;;637                    {
;;;638                        while( ( src < end ) && ( *src != '\0' ) && !isspace( *src ) && ( fieldWidth-- > 0 ) ) ++src;
0001fc  42bc              CMP      r4,r7
0001fe  d2c1              BCS      |L8.388|
000200  7821              LDRB     r1,[r4,#0]
000202  2900              CMP      r1,#0
000204  d0be              BEQ      |L8.388|
000206  5c41              LDRB     r1,[r0,r1]
000208  07c9              LSLS     r1,r1,#31
00020a  d1bb              BNE      |L8.388|
00020c  1e29              SUBS     r1,r5,#0
00020e  f1a50501          SUB      r5,r5,#1
000212  ddb7              BLE      |L8.388|
000214  e7f1              B        |L8.506|
                  |L8.534|
000216  e0ae              B        |L8.886|
                  |L8.536|
;;;639                    }
;;;640                    else if( storePtr )
000218  f1ba0f00          CMP      r10,#0
00021c  d01a              BEQ      |L8.596|
;;;641                    {
;;;642                        old = src;
00021e  4622              MOV      r2,r4
;;;643                        while( ( src < end ) && ( *src != '\0' ) && !isspace( *src ) && ( fieldWidth-- > 0 ) ) ++src;
000220  e000              B        |L8.548|
                  |L8.546|
000222  1c64              ADDS     r4,r4,#1
                  |L8.548|
000224  42bc              CMP      r4,r7
000226  d208              BCS      |L8.570|
000228  7821              LDRB     r1,[r4,#0]
00022a  b131              CBZ      r1,|L8.570|
00022c  5c41              LDRB     r1,[r0,r1]
00022e  07c9              LSLS     r1,r1,#31
000230  d103              BNE      |L8.570|
000232  1e29              SUBS     r1,r5,#0
000234  f1a50501          SUB      r5,r5,#1
000238  dcf3              BGT      |L8.546|
                  |L8.570|
;;;644    
;;;645                        ptrArg = va_arg( inArgs, const unsigned char ** );
;;;646                        if( ptrArg ) *ptrArg = old;
00023a  f8d91000          LDR      r1,[r9,#0]
00023e  f1090004          ADD      r0,r9,#4              ;645
000242  b101              CBZ      r1,|L8.582|
000244  600a              STR      r2,[r1,#0]
                  |L8.582|
;;;647    
;;;648                        sizeArg = va_arg( inArgs, size_t * );
000246  c802              LDM      r0!,{r1}
000248  4681              MOV      r9,r0
;;;649                        if( sizeArg ) *sizeArg = (size_t)( src - old );
00024a  2900              CMP      r1,#0
00024c  d0a6              BEQ      |L8.412|
00024e  1aa0              SUBS     r0,r4,r2
000250  6008              STR      r0,[r1,#0]
000252  e197              B        |L8.1412|
                  |L8.596|
;;;650    
;;;651                        ++matched;
;;;652                    }
;;;653                    else
;;;654                    {
;;;655                        s = va_arg( inArgs, unsigned char * );
000254  f8591b04          LDR      r1,[r9],#4
;;;656                        if( !s ) goto exit;
000258  2900              CMP      r1,#0
00025a  d0af              BEQ      |L8.444|
00025c  e002              B        |L8.612|
                  |L8.606|
;;;657    
;;;658                        while( ( src < end ) && ( *src != '\0' ) && !isspace( *src ) && ( fieldWidth-- > 0 ) ) *s++ = *src++;
00025e  f8012b01          STRB     r2,[r1],#1
000262  1c64              ADDS     r4,r4,#1
                  |L8.612|
000264  42bc              CMP      r4,r7
000266  d20a              BCS      |L8.638|
000268  7822              LDRB     r2,[r4,#0]
00026a  b142              CBZ      r2,|L8.638|
00026c  9803              LDR      r0,[sp,#0xc]
00026e  6800              LDR      r0,[r0,#0]
000270  5c80              LDRB     r0,[r0,r2]
000272  07c0              LSLS     r0,r0,#31
000274  d103              BNE      |L8.638|
000276  1e28              SUBS     r0,r5,#0
000278  f1a50501          SUB      r5,r5,#1
00027c  dcef              BGT      |L8.606|
                  |L8.638|
;;;659                        *s = '\0';
00027e  2000              MOVS     r0,#0
000280  7008              STRB     r0,[r1,#0]
;;;660    
;;;661                        ++matched;
000282  e17f              B        |L8.1412|
                  |L8.644|
;;;662                    }
;;;663                    continue;
;;;664    
;;;665                case '[':   // %[: Match a scanset (set between brackets or the compliment set if it starts with ^).
;;;666    
;;;667                    if( sizeModifier != 0 ) goto exit;
000284  f1bb0f00          CMP      r11,#0
000288  d1a5              BNE      |L8.470|
;;;668    
;;;669                    notSet = ( *fmt == '^' );   // A scanlist starting with ^ matches all characters not in the scanlist.
00028a  7830              LDRB     r0,[r6,#0]
00028c  285e              CMP      r0,#0x5e
00028e  d00a              BEQ      |L8.678|
000290  f04f0c00          MOV      r12,#0
                  |L8.660|
;;;670                    if( notSet ) ++fmt;
000294  f1bc0f00          CMP      r12,#0
000298  d000              BEQ      |L8.668|
00029a  1c76              ADDS     r6,r6,#1
                  |L8.668|
;;;671                    setStart = fmt;
00029c  46b3              MOV      r11,r6
;;;672                    if( *fmt == ']' ) ++fmt;    // A scanlist (after a potential ^) starting with ] includes ] in the set.
00029e  7830              LDRB     r0,[r6,#0]
0002a0  285d              CMP      r0,#0x5d
0002a2  d003              BEQ      |L8.684|
0002a4  e006              B        |L8.692|
                  |L8.678|
0002a6  f04f0c01          MOV      r12,#1                ;669
0002aa  e7f3              B        |L8.660|
                  |L8.684|
0002ac  f10b0601          ADD      r6,r11,#1
0002b0  e000              B        |L8.692|
                  |L8.690|
0002b2  1c76              ADDS     r6,r6,#1
                  |L8.692|
;;;673    
;;;674                    // Find the end of the scanlist.
;;;675    
;;;676                    while( ( *fmt != '\0' ) && ( *fmt != ']' ) ) ++fmt;
0002b4  7830              LDRB     r0,[r6,#0]
0002b6  2800              CMP      r0,#0
0002b8  d03d              BEQ      |L8.822|
0002ba  285d              CMP      r0,#0x5d
0002bc  d1f9              BNE      |L8.690|
;;;677                    if( *fmt == '\0' ) goto exit;
;;;678                    setEnd = fmt++;
0002be  4633              MOV      r3,r6
0002c0  1c76              ADDS     r6,r6,#1
;;;679    
;;;680                    // Parse until a mismatch, null terminator, or the max fieldWidth is hit.
;;;681    
;;;682                    old = src;
0002c2  4621              MOV      r1,r4
;;;683                    if( notSet )
0002c4  f1bc0f00          CMP      r12,#0
0002c8  d10c              BNE      |L8.740|
0002ca  e023              B        |L8.788|
                  |L8.716|
;;;684                    {
;;;685                        while( ( src < end ) && ( *src != '\0' ) && ( fieldWidth-- > 0 ) )
;;;686                        {
;;;687                            c = *src;
;;;688                            for( set = setStart; ( set < setEnd ) && ( *set != c ); ++set ) {}
0002cc  4658              MOV      r0,r11
0002ce  e000              B        |L8.722|
                  |L8.720|
0002d0  1c40              ADDS     r0,r0,#1
                  |L8.722|
0002d2  4298              CMP      r0,r3
0002d4  d203              BCS      |L8.734|
0002d6  f8908000          LDRB     r8,[r0,#0]
0002da  45e0              CMP      r8,r12
0002dc  d1f8              BNE      |L8.720|
                  |L8.734|
;;;689                            if( set < setEnd ) break;
0002de  4298              CMP      r0,r3
0002e0  d323              BCC      |L8.810|
0002e2  1c64              ADDS     r4,r4,#1
                  |L8.740|
0002e4  42bc              CMP      r4,r7                 ;685
0002e6  d220              BCS      |L8.810|
0002e8  f894c000          LDRB     r12,[r4,#0]           ;685
0002ec  f1bc0f00          CMP      r12,#0                ;685
0002f0  d01b              BEQ      |L8.810|
0002f2  1e28              SUBS     r0,r5,#0              ;685
0002f4  f1a50501          SUB      r5,r5,#1              ;685
0002f8  dce8              BGT      |L8.716|
0002fa  e016              B        |L8.810|
                  |L8.764|
;;;690                            ++src;
;;;691                        }
;;;692                    }
;;;693                    else
;;;694                    {
;;;695                        while( ( src < end ) && ( *src != '\0' ) && ( fieldWidth-- > 0 ) )
;;;696                        {
;;;697                            c = *src;
;;;698                            for( set = setStart; ( set < setEnd ) && ( *set != c ); ++set ) {}
0002fc  4658              MOV      r0,r11
0002fe  e000              B        |L8.770|
                  |L8.768|
000300  1c40              ADDS     r0,r0,#1
                  |L8.770|
000302  4298              CMP      r0,r3
000304  d203              BCS      |L8.782|
000306  f8908000          LDRB     r8,[r0,#0]
00030a  45e0              CMP      r8,r12
00030c  d1f8              BNE      |L8.768|
                  |L8.782|
;;;699                            if( set >= setEnd ) break;
00030e  4298              CMP      r0,r3
000310  d20b              BCS      |L8.810|
000312  1c64              ADDS     r4,r4,#1
                  |L8.788|
000314  42bc              CMP      r4,r7                 ;695
000316  d208              BCS      |L8.810|
000318  f894c000          LDRB     r12,[r4,#0]           ;695
00031c  f1bc0f00          CMP      r12,#0                ;695
000320  d003              BEQ      |L8.810|
000322  1e28              SUBS     r0,r5,#0              ;695
000324  f1a50501          SUB      r5,r5,#1              ;695
000328  dce8              BGT      |L8.764|
                  |L8.810|
;;;700                            ++src;
;;;701                        }
;;;702                    }
;;;703                    if( ( old == src ) && !alt ) goto exit;
00032a  42a1              CMP      r1,r4
00032c  d100              BNE      |L8.816|
00032e  b112              CBZ      r2,|L8.822|
                  |L8.816|
;;;704                    if( !suppress )
000330  9801              LDR      r0,[sp,#4]
000332  2800              CMP      r0,#0
000334  e001              B        |L8.826|
                  |L8.822|
000336  e040              B        |L8.954|
000338  e02e              B        |L8.920|
                  |L8.826|
00033a  f47faf23          BNE      |L8.388|
;;;705                    {
;;;706                        if( storePtr )
00033e  f1ba0f00          CMP      r10,#0
000342  d00b              BEQ      |L8.860|
;;;707                        {
;;;708                            ptrArg = va_arg( inArgs, const unsigned char ** );
;;;709                            if( ptrArg ) *ptrArg = old;
000344  f8d92000          LDR      r2,[r9,#0]
000348  f1090004          ADD      r0,r9,#4              ;708
00034c  b102              CBZ      r2,|L8.848|
00034e  6011              STR      r1,[r2,#0]
                  |L8.848|
;;;710    
;;;711                            sizeArg = va_arg( inArgs, size_t * );
000350  c804              LDM      r0!,{r2}
000352  4681              MOV      r9,r0
;;;712                            if( sizeArg ) *sizeArg = (size_t)( src - old );
000354  b382              CBZ      r2,|L8.952|
000356  1a60              SUBS     r0,r4,r1
000358  6010              STR      r0,[r2,#0]
00035a  e113              B        |L8.1412|
                  |L8.860|
;;;713                        }
;;;714                        else
;;;715                        {
;;;716                            s = va_arg( inArgs, unsigned char * );
00035c  f8590b04          LDR      r0,[r9],#4
;;;717                            if( !s ) goto exit;
000360  b358              CBZ      r0,|L8.954|
000362  e003              B        |L8.876|
                  |L8.868|
;;;718    
;;;719                            while( old < src ) *s++ = *old++;
000364  f8112b01          LDRB     r2,[r1],#1
000368  f8002b01          STRB     r2,[r0],#1
                  |L8.876|
00036c  42a1              CMP      r1,r4
00036e  d3f9              BCC      |L8.868|
;;;720                            *s = '\0';
000370  2100              MOVS     r1,#0
000372  7001              STRB     r1,[r0,#0]
000374  e106              B        |L8.1412|
                  |L8.886|
;;;721                        }
;;;722                        ++matched;
;;;723                    }
;;;724                    continue;
;;;725    
;;;726                case '%':   // %%: Match a literal % character.
;;;727    
;;;728                    if( sizeModifier != 0 )     goto exit;
000376  f1bb0f00          CMP      r11,#0
00037a  d11e              BNE      |L8.954|
;;;729                    if( fieldWidth != INT_MAX ) goto exit;
00037c  f06f4000          MVN      r0,#0x80000000
000380  4285              CMP      r5,r0
000382  d11a              BNE      |L8.954|
;;;730                    if( suppress )              goto exit;
000384  9801              LDR      r0,[sp,#4]
000386  b9c0              CBNZ     r0,|L8.954|
;;;731                    if( src >= end )            goto exit;
000388  42bc              CMP      r4,r7
00038a  d216              BCS      |L8.954|
;;;732                    if( *src++ != '%' )         goto exit;
00038c  f8140b01          LDRB     r0,[r4],#1
000390  2825              CMP      r0,#0x25
000392  f43faef7          BEQ      |L8.388|
000396  e0e5              B        |L8.1380|
                  |L8.920|
;;;733                    continue;
;;;734    
;;;735                case 'n':   // %n: Return the number of characters read so far.
;;;736    
;;;737                    if( sizeModifier != 0 )     goto exit;
000398  f1bb0f00          CMP      r11,#0
00039c  d10d              BNE      |L8.954|
;;;738                    if( fieldWidth != INT_MAX ) goto exit;
00039e  f06f4000          MVN      r0,#0x80000000
0003a2  4285              CMP      r5,r0
0003a4  d109              BNE      |L8.954|
;;;739                    if( suppress )              goto exit;
0003a6  9801              LDR      r0,[sp,#4]
0003a8  b938              CBNZ     r0,|L8.954|
;;;740    
;;;741                    i = va_arg( inArgs, int * );
0003aa  f8590b04          LDR      r0,[r9],#4
;;;742                    if( !i ) goto exit;
0003ae  b120              CBZ      r0,|L8.954|
;;;743    
;;;744                    *i = (int)( src - ( (const unsigned char *) inString ) );
0003b0  9907              LDR      r1,[sp,#0x1c]
0003b2  1a61              SUBS     r1,r4,r1
;;;745                    continue;
0003b4  6001              STR      r1,[r0,#0]
0003b6  e635              B        |L8.36|
                  |L8.952|
0003b8  e0e4              B        |L8.1412|
                  |L8.954|
0003ba  e0d3              B        |L8.1380|
                  |L8.956|
0003bc  1c64              ADDS     r4,r4,#1
                  |L8.958|
;;;746    
;;;747                default:    // Unknown conversion.
;;;748                    goto exit;
;;;749            }
;;;750    
;;;751            // Number conversion. Skip leading white space since number conversions ignore leading white space.
;;;752    
;;;753            while( ( src < end ) && isspace( *src ) ) ++src;
0003be  42bc              CMP      r4,r7
0003c0  d203              BCS      |L8.970|
0003c2  7821              LDRB     r1,[r4,#0]
0003c4  5c41              LDRB     r1,[r0,r1]
0003c6  07c9              LSLS     r1,r1,#31
0003c8  d1f8              BNE      |L8.956|
                  |L8.970|
;;;754    
;;;755            // Handle +/- prefix for negative/positive (even for unsigned numbers).
;;;756    
;;;757            negative = 0;
0003ca  2000              MOVS     r0,#0
;;;758            if( ( ( end - src ) > 1 ) && ( fieldWidth > 0 ) )
0003cc  9004              STR      r0,[sp,#0x10]
0003ce  1b38              SUBS     r0,r7,r4
0003d0  2801              CMP      r0,#1
0003d2  dd0b              BLE      |L8.1004|
0003d4  2d00              CMP      r5,#0
0003d6  dd09              BLE      |L8.1004|
;;;759            {
;;;760                if( src[ 0 ] == '-' )
0003d8  7820              LDRB     r0,[r4,#0]
0003da  282d              CMP      r0,#0x2d
0003dc  d002              BEQ      |L8.996|
;;;761                {
;;;762                    negative = 1;
;;;763                    ++src;
;;;764                    --fieldWidth;
;;;765                }
;;;766                else if( src[ 0 ] == '+' )
0003de  282b              CMP      r0,#0x2b
0003e0  d002              BEQ      |L8.1000|
0003e2  e003              B        |L8.1004|
                  |L8.996|
0003e4  2001              MOVS     r0,#1                 ;762
0003e6  9004              STR      r0,[sp,#0x10]         ;762
                  |L8.1000|
0003e8  1c64              ADDS     r4,r4,#1              ;762
0003ea  1e6d              SUBS     r5,r5,#1              ;762
                  |L8.1004|
;;;767                {
;;;768                    ++src;
;;;769                    --fieldWidth;
;;;770                }
;;;771            }
;;;772    
;;;773            // Detect the base for base 0 and skip valid prefixes.
;;;774    
;;;775            old = src;
;;;776            if( base == 0 )
0003ec  9405              STR      r4,[sp,#0x14]
0003ee  f1ba0f00          CMP      r10,#0
0003f2  d006              BEQ      |L8.1026|
;;;777            {
;;;778                if( ( ( end - src ) > 2 ) && ( fieldWidth >= 2 ) &&
;;;779                    ( src[ 0 ] == '0' ) && ( tolower( src[ 1 ] ) == 'x' ) && isxdigit( src[ 2 ] ) )
;;;780                {
;;;781                    base         = 16;
;;;782                    src         +=  2;
;;;783                    fieldWidth  -=  2;
;;;784                }
;;;785                else if( ( ( end - src ) > 2 ) && ( fieldWidth >= 2 ) &&
;;;786                         ( src[ 0 ] == '0' ) && ( tolower( src[ 1 ] ) == 'b' ) &&
;;;787                         ( ( src[ 2 ] == '0' ) || ( src[ 2 ] == '1' ) ) )
;;;788                {
;;;789                    base         = 2;
;;;790                    src         += 2;
;;;791                    fieldWidth  -= 2;
;;;792                }
;;;793                else if( ( ( end - src ) > 1 ) && ( fieldWidth >= 1 ) &&
;;;794                         ( src[ 0 ] == '0' ) && ( src[ 1 ] >= '0' ) && ( src[ 1 ] <= '7' ) )
;;;795                {
;;;796                    base         = 8;
;;;797                    src         += 1;
;;;798                    fieldWidth  -= 1;
;;;799                }
;;;800                else
;;;801                {
;;;802                    base = 10;
;;;803                }
;;;804            }
;;;805            else if( ( base == 16 ) && ( ( end - src ) >= 2 ) && ( fieldWidth >= 2 ) &&
0003f4  f1ba0f10          CMP      r10,#0x10
0003f8  d03e              BEQ      |L8.1144|
;;;806                     ( src[ 0 ] == '0' ) && ( tolower( src[ 1 ] ) == 'x' ) )
;;;807            {
;;;808                src         += 2;
;;;809                fieldWidth  -= 2;
;;;810            }
;;;811            else if( ( base == 2 ) && ( ( end - src ) >= 2 ) && ( fieldWidth >= 2 ) &&
0003fa  f1ba0f02          CMP      r10,#2
0003fe  d049              BEQ      |L8.1172|
000400  e057              B        |L8.1202|
                  |L8.1026|
000402  1b38              SUBS     r0,r7,r4              ;778
000404  2802              CMP      r0,#2                 ;778
000406  dd23              BLE      |L8.1104|
000408  2d02              CMP      r5,#2                 ;778
00040a  db23              BLT      |L8.1108|
00040c  7820              LDRB     r0,[r4,#0]            ;779
00040e  2830              CMP      r0,#0x30              ;779
000410  d120              BNE      |L8.1108|
000412  7860              LDRB     r0,[r4,#1]            ;779
000414  f7fffffe          BL       tolower
000418  2878              CMP      r0,#0x78              ;779
00041a  d109              BNE      |L8.1072|
00041c  9803              LDR      r0,[sp,#0xc]          ;779
00041e  78a1              LDRB     r1,[r4,#2]            ;779
000420  6800              LDR      r0,[r0,#0]            ;779
000422  5c40              LDRB     r0,[r0,r1]            ;779
000424  ea800080          EOR      r0,r0,r0,LSL #2       ;779
000428  0600              LSLS     r0,r0,#24             ;779
00042a  d501              BPL      |L8.1072|
00042c  2010              MOVS     r0,#0x10              ;781
00042e  e00d              B        |L8.1100|
                  |L8.1072|
000430  7820              LDRB     r0,[r4,#0]            ;786
000432  2830              CMP      r0,#0x30              ;786
000434  d10e              BNE      |L8.1108|
000436  7860              LDRB     r0,[r4,#1]            ;786
000438  f7fffffe          BL       tolower
00043c  2862              CMP      r0,#0x62              ;786
00043e  d109              BNE      |L8.1108|
000440  78a0              LDRB     r0,[r4,#2]            ;787
000442  2830              CMP      r0,#0x30              ;787
000444  d001              BEQ      |L8.1098|
000446  2831              CMP      r0,#0x31              ;787
000448  d104              BNE      |L8.1108|
                  |L8.1098|
00044a  2002              MOVS     r0,#2                 ;789
                  |L8.1100|
00044c  4682              MOV      r10,r0                ;781
00044e  e02e              B        |L8.1198|
                  |L8.1104|
000450  2801              CMP      r0,#1                 ;793
000452  dd0e              BLE      |L8.1138|
                  |L8.1108|
000454  2d01              CMP      r5,#1                 ;793
000456  db0c              BLT      |L8.1138|
000458  7820              LDRB     r0,[r4,#0]            ;794
00045a  2830              CMP      r0,#0x30              ;794
00045c  d109              BNE      |L8.1138|
00045e  7860              LDRB     r0,[r4,#1]            ;794
000460  2830              CMP      r0,#0x30              ;794
000462  d306              BCC      |L8.1138|
000464  2837              CMP      r0,#0x37              ;794
000466  d804              BHI      |L8.1138|
000468  1c64              ADDS     r4,r4,#1              ;796
00046a  f04f0a08          MOV      r10,#8                ;796
00046e  1e6d              SUBS     r5,r5,#1              ;796
000470  e01f              B        |L8.1202|
                  |L8.1138|
000472  f04f0a0a          MOV      r10,#0xa              ;802
000476  e01c              B        |L8.1202|
                  |L8.1144|
000478  1b38              SUBS     r0,r7,r4              ;805
00047a  2802              CMP      r0,#2                 ;805
00047c  db19              BLT      |L8.1202|
00047e  2d02              CMP      r5,#2                 ;805
000480  db17              BLT      |L8.1202|
000482  7820              LDRB     r0,[r4,#0]            ;806
000484  2830              CMP      r0,#0x30              ;806
000486  d114              BNE      |L8.1202|
000488  7860              LDRB     r0,[r4,#1]            ;806
00048a  f7fffffe          BL       tolower
00048e  2878              CMP      r0,#0x78              ;806
000490  d00d              BEQ      |L8.1198|
000492  e00e              B        |L8.1202|
                  |L8.1172|
000494  1b38              SUBS     r0,r7,r4
000496  2802              CMP      r0,#2
000498  db0b              BLT      |L8.1202|
00049a  2d02              CMP      r5,#2
00049c  db09              BLT      |L8.1202|
;;;812                     ( src[ 0 ] == '0' ) && ( tolower( src[ 1 ] ) == 'b' ) )
00049e  7820              LDRB     r0,[r4,#0]
0004a0  2830              CMP      r0,#0x30
0004a2  d106              BNE      |L8.1202|
0004a4  7860              LDRB     r0,[r4,#1]
0004a6  f7fffffe          BL       tolower
0004aa  2862              CMP      r0,#0x62
0004ac  d101              BNE      |L8.1202|
                  |L8.1198|
0004ae  1ca4              ADDS     r4,r4,#2
0004b0  1ead              SUBS     r5,r5,#2
                  |L8.1202|
0004b2  2100              MOVS     r1,#0
;;;813            {
;;;814                src         += 2;
;;;815                fieldWidth  -= 2;
;;;816            }
;;;817    
;;;818            // Convert the string to a number.
;;;819    
;;;820            x = 0;
0004b4  4688              MOV      r8,r1
;;;821            while( ( src < end ) && ( fieldWidth-- > 0 ) )
0004b6  9102              STR      r1,[sp,#8]
0004b8  e021              B        |L8.1278|
                  |L8.1210|
;;;822            {
;;;823                c = *src;
;;;824                if(      isdigit(  c ) ) v = c - '0';
0004ba  9803              LDR      r0,[sp,#0xc]
0004bc  7821              LDRB     r1,[r4,#0]            ;823
0004be  6800              LDR      r0,[r0,#0]
0004c0  5c40              LDRB     r0,[r0,r1]
0004c2  2820              CMP      r0,#0x20
0004c4  d042              BEQ      |L8.1356|
0004c6  ea800080          EOR      r0,r0,r0,LSL #2
;;;825                else if( isxdigit( c ) ) v = 10 + ( tolower( c ) - 'a' );
0004ca  0600              LSLS     r0,r0,#24
0004cc  d51d              BPL      |L8.1290|
0004ce  4608              MOV      r0,r1
0004d0  f7fffffe          BL       tolower
0004d4  f1a00e57          SUB      lr,r0,#0x57
                  |L8.1240|
;;;826                else break;
;;;827                if( v >= base ) break;
0004d8  45d6              CMP      lr,r10
0004da  da16              BGE      |L8.1290|
;;;828    
;;;829                x = ( x * base ) + v;
0004dc  4641              MOV      r1,r8
0004de  fba1280a          UMULL    r2,r8,r1,r10
0004e2  9b02              LDR      r3,[sp,#8]
0004e4  ea4f7cea          ASR      r12,r10,#31
0004e8  fb03800a          MLA      r0,r3,r10,r8
0004ec  fb01010c          MLA      r1,r1,r12,r0
0004f0  eb12080e          ADDS     r8,r2,lr
0004f4  eb4171ee          ADC      r1,r1,lr,ASR #31
0004f8  f1040401          ADD      r4,r4,#1
0004fc  9102              STR      r1,[sp,#8]
                  |L8.1278|
0004fe  42bc              CMP      r4,r7                 ;821
000500  d203              BCS      |L8.1290|
000502  1e28              SUBS     r0,r5,#0              ;821
000504  f1a50501          SUB      r5,r5,#1              ;821
000508  dcd7              BGT      |L8.1210|
                  |L8.1290|
;;;830                ++src;
;;;831            }
;;;832            if( src == old ) goto exit;
00050a  9805              LDR      r0,[sp,#0x14]
00050c  4284              CMP      r4,r0
00050e  d029              BEQ      |L8.1380|
;;;833            if( suppress )   continue;
000510  9801              LDR      r0,[sp,#4]
000512  2800              CMP      r0,#0
000514  f47fae36          BNE      |L8.388|
;;;834            if( negative )   x = -x;
000518  9804              LDR      r0,[sp,#0x10]
00051a  b130              CBZ      r0,|L8.1322|
00051c  2000              MOVS     r0,#0
00051e  9a02              LDR      r2,[sp,#8]
000520  f1d80800          RSBS     r8,r8,#0
000524  eb600002          SBC      r0,r0,r2
000528  9002              STR      r0,[sp,#8]
                  |L8.1322|
;;;835    
;;;836            // Store the result.
;;;837    
;;;838            p = va_arg( inArgs, void * );
00052a  f8590b04          LDR      r0,[r9],#4
;;;839            if( !p ) goto exit;
00052e  b1c8              CBZ      r0,|L8.1380|
;;;840    
;;;841            switch( sizeModifier )
000530  4659              MOV      r1,r11
000532  f1bb0f6a          CMP      r11,#0x6a
000536  d022              BEQ      |L8.1406|
000538  dc0b              BGT      |L8.1362|
00053a  b1b9              CBZ      r1,|L8.1388|
00053c  2948              CMP      r1,#0x48
00053e  d018              BEQ      |L8.1394|
000540  294c              CMP      r1,#0x4c
000542  d01c              BEQ      |L8.1406|
000544  f1bb0f68          CMP      r11,#0x68
000548  d10c              BNE      |L8.1380|
00054a  e015              B        |L8.1400|
                  |L8.1356|
00054c  f1a10e30          SUB      lr,r1,#0x30
000550  e7c2              B        |L8.1240|
                  |L8.1362|
000552  296c              CMP      r1,#0x6c
000554  d00a              BEQ      |L8.1388|
000556  2970              CMP      r1,#0x70
000558  d008              BEQ      |L8.1388|
00055a  2974              CMP      r1,#0x74
00055c  d006              BEQ      |L8.1388|
00055e  f1bb0f7a          CMP      r11,#0x7a
000562  d003              BEQ      |L8.1388|
                  |L8.1380|
;;;842            {
;;;843                case   0: *( (int       *) p ) = (int)                  x; break;
;;;844                case 'l': *( (long      *) p ) = (long)                 x; break;
;;;845                case 'H': *( (char      *) p ) = (char)                 x; break;
;;;846                case 'h': *( (short     *) p ) = (short)                x; break;
;;;847                case 'L': *( (int64_t   *) p ) =                        x; break;
;;;848                case 'j': *( (intmax_t  *) p ) = (intmax_t)             x; break;
;;;849                case 'z': *( (size_t    *) p ) = (size_t)               x; break;
;;;850                case 't': *( (ptrdiff_t *) p ) = (ptrdiff_t)            x; break;
;;;851                case 'p': *( (void     **) p ) = (void *)( (uintptr_t)  x ); break;
;;;852    
;;;853                default:    // Unknown size modifier.
;;;854                    goto exit;
;;;855            }
;;;856            ++matched;
;;;857        }
;;;858    
;;;859    exit:
;;;860        return( matched );
000564  9800              LDR      r0,[sp,#0]
;;;861    }
000566  b00b              ADD      sp,sp,#0x2c
000568  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.1388|
00056c  f8c08000          STR      r8,[r0,#0]            ;843
000570  e008              B        |L8.1412|
                  |L8.1394|
000572  f8808000          STRB     r8,[r0,#0]            ;845
000576  e005              B        |L8.1412|
                  |L8.1400|
000578  f8a08000          STRH     r8,[r0,#0]            ;846
00057c  e002              B        |L8.1412|
                  |L8.1406|
00057e  9902              LDR      r1,[sp,#8]            ;847
000580  e9c08100          STRD     r8,r1,[r0,#0]         ;847
                  |L8.1412|
000584  9800              LDR      r0,[sp,#0]            ;856
000586  1c40              ADDS     r0,r0,#1              ;856
000588  9000              STR      r0,[sp,#0]            ;491
00058a  e54b              B        |L8.36|
;;;862    
                          ENDP


                          AREA ||i.__strdup||, CODE, READONLY, ALIGN=1

                  __strdup PROC
;;;55     //===========================================================================================================================
;;;56     char *__strdup(const char *src)
000000  b570              PUSH     {r4-r6,lr}
;;;57     {
000002  0004              MOVS     r4,r0
000004  d011              BEQ      |L9.42|
;;;58       int len;
;;;59       char *dst;
;;;60       
;;;61       if (src == NULL)
;;;62         return NULL;
;;;63       
;;;64       if (src[0] == 0)
000006  7820              LDRB     r0,[r4,#0]
000008  2800              CMP      r0,#0
00000a  d00d              BEQ      |L9.40|
;;;65         return NULL;
;;;66       
;;;67       len = strlen(src) + 1;
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       strlen
000012  1c40              ADDS     r0,r0,#1
000014  4606              MOV      r6,r0
;;;68       dst = (char*)malloc(len);
000016  f7fffffe          BL       malloc
00001a  0005              MOVS     r5,r0
;;;69       if (dst) 
00001c  d003              BEQ      |L9.38|
;;;70         memcpy(dst, src, len);
00001e  4632              MOV      r2,r6
000020  4621              MOV      r1,r4
000022  f7fffffe          BL       __aeabi_memcpy
                  |L9.38|
;;;71       return dst;
000026  4628              MOV      r0,r5
                  |L9.40|
;;;72     }
000028  bd70              POP      {r4-r6,pc}
                  |L9.42|
00002a  2000              MOVS     r0,#0                 ;62
00002c  bd70              POP      {r4-r6,pc}
;;;73     
                          ENDP


                          AREA ||i.__strdup_trans_dot||, CODE, READONLY, ALIGN=1

                  __strdup_trans_dot PROC
;;;73     
;;;74     char *__strdup_trans_dot(char *src)
000000  b570              PUSH     {r4-r6,lr}
;;;75     {
000002  4604              MOV      r4,r0
;;;76         char *dst, *dstTemp;
;;;77         char *srcTemp = src;
000004  4605              MOV      r5,r0
;;;78         uint32_t newLen = strlen(src)+1;
000006  f7fffffe          BL       strlen
00000a  1c40              ADDS     r0,r0,#1
;;;79     
;;;80         while(*srcTemp!= 0) {
00000c  e003              B        |L10.22|
                  |L10.14|
;;;81             if (*srcTemp == '.') 
00000e  292e              CMP      r1,#0x2e
000010  d100              BNE      |L10.20|
000012  1c40              ADDS     r0,r0,#1
                  |L10.20|
000014  1c6d              ADDS     r5,r5,#1
                  |L10.22|
000016  7829              LDRB     r1,[r5,#0]            ;80
000018  2900              CMP      r1,#0                 ;80
00001a  d1f8              BNE      |L10.14|
;;;82                 newLen++;
;;;83             srcTemp++;
;;;84         }
;;;85     
;;;86         dst = malloc(newLen);
00001c  f7fffffe          BL       malloc
000020  232e              MOVS     r3,#0x2e              ;81
000022  4602              MOV      r2,r0
;;;87         dstTemp = dst;
;;;88         srcTemp = src;
;;;89     
;;;90         while(*srcTemp!= 0) {
;;;91             if (*srcTemp == '.') {
;;;92                 *dstTemp++ = '/';
000024  252f              MOVS     r5,#0x2f
000026  e004              B        |L10.50|
                  |L10.40|
000028  292e              CMP      r1,#0x2e              ;91
00002a  d008              BEQ      |L10.62|
;;;93                 *dstTemp++ = '.';
;;;94                 srcTemp++;
;;;95             } else {
;;;96                 *dstTemp++ = *srcTemp++;
00002c  f8001b01          STRB     r1,[r0],#1
                  |L10.48|
000030  1c64              ADDS     r4,r4,#1
                  |L10.50|
000032  7821              LDRB     r1,[r4,#0]            ;90
000034  2900              CMP      r1,#0                 ;90
000036  d1f7              BNE      |L10.40|
;;;97             }
;;;98         }
;;;99         *dstTemp = 0x0;
000038  7001              STRB     r1,[r0,#0]
;;;100        return dst;
00003a  4610              MOV      r0,r2
;;;101    }
00003c  bd70              POP      {r4-r6,pc}
                  |L10.62|
00003e  f8005b01          STRB     r5,[r0],#1            ;92
000042  f8003b01          STRB     r3,[r0],#1            ;93
000046  e7f3              B        |L10.48|
;;;102    
                          ENDP


                          AREA ||i.formatMACAddr||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  formatMACAddr PROC
;;;39     //===========================================================================================================================
;;;40     void formatMACAddr(char *destAddr, char *srcAddr)
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;41     {
000004  b08b              SUB      sp,sp,#0x2c
000006  460c              MOV      r4,r1
;;;42       sprintf((char *)destAddr, "%c%c:%c%c:%c%c:%c%c:%c%c:%c%c",\
000008  7ac8              LDRB     r0,[r1,#0xb]
00000a  f7fffffe          BL       toupper
00000e  4683              MOV      r11,r0
000010  7aa0              LDRB     r0,[r4,#0xa]
000012  f7fffffe          BL       toupper
000016  4682              MOV      r10,r0
000018  7a60              LDRB     r0,[r4,#9]
00001a  f7fffffe          BL       toupper
00001e  9002              STR      r0,[sp,#8]
000020  7a20              LDRB     r0,[r4,#8]
000022  f7fffffe          BL       toupper
000026  4681              MOV      r9,r0
000028  79e0              LDRB     r0,[r4,#7]
00002a  f7fffffe          BL       toupper
00002e  9000              STR      r0,[sp,#0]
000030  79a0              LDRB     r0,[r4,#6]
000032  f7fffffe          BL       toupper
000036  9001              STR      r0,[sp,#4]
000038  7960              LDRB     r0,[r4,#5]
00003a  f7fffffe          BL       toupper
00003e  4680              MOV      r8,r0
000040  7920              LDRB     r0,[r4,#4]
000042  f7fffffe          BL       toupper
000046  4607              MOV      r7,r0
000048  78e0              LDRB     r0,[r4,#3]
00004a  f7fffffe          BL       toupper
00004e  4606              MOV      r6,r0
000050  78a0              LDRB     r0,[r4,#2]
000052  f7fffffe          BL       toupper
000056  4605              MOV      r5,r0
000058  7860              LDRB     r0,[r4,#1]
00005a  f7fffffe          BL       toupper
00005e  900a              STR      r0,[sp,#0x28]
000060  7820              LDRB     r0,[r4,#0]
000062  f7fffffe          BL       toupper
000066  4602              MOV      r2,r0
000068  9b02              LDR      r3,[sp,#8]
00006a  a807              ADD      r0,sp,#0x1c
00006c  f8cd9018          STR      r9,[sp,#0x18]
000070  e8800c08          STM      r0,{r3,r10,r11}
000074  e9dd1300          LDRD     r1,r3,[sp,#0]
000078  e9cd3104          STRD     r3,r1,[sp,#0x10]
00007c  e88d01e0          STM      sp,{r5-r8}
000080  e9dd300a          LDRD     r3,r0,[sp,#0x28]
000084  a102              ADR      r1,|L11.144|
000086  f7fffffe          BL       __2sprintf
;;;43                         toupper(*(char *)srcAddr),toupper(*((char *)(srcAddr)+1)),\
;;;44                         toupper(*((char *)(srcAddr)+2)),toupper(*((char *)(srcAddr)+3)),\
;;;45                         toupper(*((char *)(srcAddr)+4)),toupper(*((char *)(srcAddr)+5)),\
;;;46                         toupper(*((char *)(srcAddr)+6)),toupper(*((char *)(srcAddr)+7)),\
;;;47                         toupper(*((char *)(srcAddr)+8)),toupper(*((char *)(srcAddr)+9)),\
;;;48                         toupper(*((char *)(srcAddr)+10)),toupper(*((char *)(srcAddr)+11)));
;;;49     }
00008a  b00d              ADD      sp,sp,#0x34
00008c  e8bd8ff0          POP      {r4-r11,pc}
;;;50     
                          ENDP

                  |L11.144|
000090  25632563          DCB      "%c%c:%c%c:%c%c:%c%c:%c%c:%c%c",0
000094  3a256325
000098  633a2563
00009c  25633a25
0000a0  6325633a
0000a4  25632563
0000a8  3a256325
0000ac  6300    
0000ae  00                DCB      0
0000af  00                DCB      0

                          AREA ||i.memmem||, CODE, READONLY, ALIGN=1

                  memmem PROC
;;;925    
;;;926    void *memmem(void *start, unsigned int s_len, void *find, unsigned int f_len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;927    {
;;;928        char                *p, *q;
;;;929        unsigned int        len;
;;;930    
;;;931        p = start, q = find;
000002  4604              MOV      r4,r0
000004  e00a              B        |L12.28|
                  |L12.6|
000006  1c76              ADDS     r6,r6,#1              ;927
;;;932        len = 0;
;;;933        while((p - (char *)start + f_len) <= s_len){
;;;934            while(*p++ == *q++){
;;;935                len++;
;;;936                if(len == f_len)
000008  429e              CMP      r6,r3
00000a  d101              BNE      |L12.16|
;;;937                    return(p - f_len);
00000c  1ae0              SUBS     r0,r4,r3
;;;938            };
;;;939            q = find;
;;;940            len = 0;
;;;941        };
;;;942    
;;;943        return(NULL);
;;;944    }
00000e  bdf0              POP      {r4-r7,pc}
                  |L12.16|
000010  f8147b01          LDRB     r7,[r4],#1            ;934
000014  f815cb01          LDRB     r12,[r5],#1           ;934
000018  4567              CMP      r7,r12                ;934
00001a  d0f4              BEQ      |L12.6|
                  |L12.28|
00001c  1a27              SUBS     r7,r4,r0              ;933
00001e  2600              MOVS     r6,#0                 ;940
000020  441f              ADD      r7,r7,r3              ;933
000022  4615              MOV      r5,r2                 ;939
000024  428f              CMP      r7,r1                 ;933
000026  d9f3              BLS      |L12.16|
000028  2000              MOVS     r0,#0                 ;943
00002a  bdf0              POP      {r4-r7,pc}
;;;945    
                          ENDP


                          AREA ||i.strnicmp||, CODE, READONLY, ALIGN=1

                  strnicmp PROC
;;;383    
;;;384    int strnicmp( const char *inS1, const char *inS2, size_t inMax )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;385    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;386        const char *        end;
;;;387        int                 c1;
;;;388        int                 c2;
;;;389    
;;;390        end = inS1 + inMax;
000008  1887              ADDS     r7,r0,r2
00000a  e015              B        |L13.56|
                  |L13.12|
;;;391        while( inS1 < end )
;;;392        {
;;;393            c1 = tolower( *( (const unsigned char *) inS1 ) );
00000c  7820              LDRB     r0,[r4,#0]
00000e  f7fffffe          BL       tolower
000012  4606              MOV      r6,r0
;;;394            c2 = tolower( *( (const unsigned char *) inS2 ) );
000014  7828              LDRB     r0,[r5,#0]
000016  f7fffffe          BL       tolower
;;;395            if( c1 < c2 )    return( -1 );
00001a  4286              CMP      r6,r0
00001c  da03              BGE      |L13.38|
00001e  f04f30ff          MOV      r0,#0xffffffff
                  |L13.34|
;;;396            if( c1 > c2 )    return(  1 );
;;;397            if( c1 == '\0' ) break;
;;;398    
;;;399            ++inS1;
;;;400            ++inS2;
;;;401        }
;;;402        return( 0 );
;;;403    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L13.38|
000026  dd02              BLE      |L13.46|
000028  f04f0001          MOV      r0,#1                 ;396
00002c  e7f9              B        |L13.34|
                  |L13.46|
00002e  b12e              CBZ      r6,|L13.60|
000030  f1040401          ADD      r4,r4,#1              ;397
000034  f1050501          ADD      r5,r5,#1              ;397
                  |L13.56|
000038  42bc              CMP      r4,r7                 ;391
00003a  d3e7              BCC      |L13.12|
                  |L13.60|
00003c  2000              MOVS     r0,#0                 ;402
00003e  e7f0              B        |L13.34|
;;;404    
                          ENDP


                          AREA ||i.strnicmp_suffix||, CODE, READONLY, ALIGN=1

                  strnicmp_suffix PROC
;;;868    
;;;869    int strnicmp_suffix( const void *inStr, size_t inMaxLen, const char *inSuffix )
000000  b570              PUSH     {r4-r6,lr}
;;;870    {
000002  4616              MOV      r6,r2
000004  4605              MOV      r5,r0
;;;871        const char *        stringPtr;
;;;872        size_t              stringLen;
;;;873        size_t              suffixLen;
;;;874    
;;;875        stringPtr = (const char *) inStr;
;;;876        stringLen = strnlen( stringPtr, inMaxLen );
000006  f7fffffe          BL       strnlen
00000a  4604              MOV      r4,r0
;;;877        suffixLen = strlen( inSuffix );
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       strlen
000012  4601              MOV      r1,r0
;;;878        if( suffixLen <= stringLen )
000014  42a0              CMP      r0,r4
000016  d806              BHI      |L14.38|
;;;879        {
;;;880            return( strnicmpx( stringPtr + ( stringLen - suffixLen ), suffixLen, inSuffix ) );
000018  1a60              SUBS     r0,r4,r1
00001a  4428              ADD      r0,r0,r5
00001c  4632              MOV      r2,r6
00001e  e8bd4070          POP      {r4-r6,lr}
000022  f7ffbffe          B.W      strnicmpx
                  |L14.38|
;;;881        }
;;;882        return( -1 );
000026  f04f30ff          MOV      r0,#0xffffffff
;;;883    }
00002a  bd70              POP      {r4-r6,pc}
;;;884    
                          ENDP


                          AREA ||i.strnicmpx||, CODE, READONLY, ALIGN=1

                  strnicmpx PROC
;;;410    
;;;411    int strnicmpx( const void *inS1, size_t inN, const char *inS2 )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;412    {
000004  4614              MOV      r4,r2
000006  460e              MOV      r6,r1
000008  4605              MOV      r5,r0
;;;413        const unsigned char *       s1;
;;;414        const unsigned char *       s2;
;;;415        int                         c1;
;;;416        int                         c2;
;;;417    
;;;418        s1 = (const unsigned char *) inS1;
;;;419        s2 = (const unsigned char *) inS2;
;;;420        while( inN-- > 0 )
;;;421        {
;;;422            c1 = tolower( *s1 );
;;;423            c2 = tolower( *s2 );
;;;424            if( c1 < c2 ) return( -1 );
00000a  f04f38ff          MOV      r8,#0xffffffff
00000e  e013              B        |L15.56|
                  |L15.16|
000010  7828              LDRB     r0,[r5,#0]            ;422
000012  f7fffffe          BL       tolower
000016  4607              MOV      r7,r0                 ;422
000018  7820              LDRB     r0,[r4,#0]            ;423
00001a  f7fffffe          BL       tolower
00001e  4287              CMP      r7,r0
000020  db0f              BLT      |L15.66|
;;;425            if( c1 > c2 ) return(  1 );
000022  dd03              BLE      |L15.44|
000024  f04f0001          MOV      r0,#1
                  |L15.40|
;;;426            if( c2 == 0 ) return(  0 );
;;;427    
;;;428            ++s1;
;;;429            ++s2;
;;;430        }
;;;431        if( *s2 != 0 ) return( -1 );
;;;432        return( 0 );
;;;433    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L15.44|
00002c  2800              CMP      r0,#0                 ;426
00002e  d0fb              BEQ      |L15.40|
000030  f1040401          ADD      r4,r4,#1              ;426
000034  f1050501          ADD      r5,r5,#1              ;426
                  |L15.56|
000038  1e76              SUBS     r6,r6,#1              ;426
00003a  d2e9              BCS      |L15.16|
00003c  7820              LDRB     r0,[r4,#0]            ;431
00003e  2800              CMP      r0,#0                 ;431
000040  d0f2              BEQ      |L15.40|
                  |L15.66|
000042  4640              MOV      r0,r8                 ;431
000044  e7f0              B        |L15.40|
;;;434    
                          ENDP


                          AREA ||i.strnlen||, CODE, READONLY, ALIGN=1

                  strnlen PROC
;;;126    #if defined (__CC_ARM)
;;;127    size_t strnlen(const char *str, size_t maxsize)  
000000  4602              MOV      r2,r0
;;;128    {  
;;;129      size_t n;  
;;;130      
;;;131      /* Note that we do not check if s == NULL, because we do not  
;;;132      * return errno_t...  
;;;133      */  
;;;134      
;;;135      for (n = 0; n < maxsize && *str; n++, str++)  
000002  2000              MOVS     r0,#0
000004  e001              B        |L16.10|
                  |L16.6|
000006  1c40              ADDS     r0,r0,#1              ;128
000008  1c52              ADDS     r2,r2,#1              ;128
                  |L16.10|
00000a  4288              CMP      r0,r1
00000c  d202              BCS      |L16.20|
00000e  7813              LDRB     r3,[r2,#0]
000010  2b00              CMP      r3,#0
000012  d1f8              BNE      |L16.6|
                  |L16.20|
;;;136      ;  
;;;137      
;;;138      return n;  
;;;139    }  
000014  4770              BX       lr
;;;140    #endif
                          ENDP


                          AREA ||i.strnstr_suffix||, CODE, READONLY, ALIGN=1

                  strnstr_suffix PROC
;;;891    
;;;892    char * strnstr_suffix( const char *inStr, size_t inMaxLen, const char *inSuffix)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;893    {
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
000008  4692              MOV      r10,r2
;;;894        size_t              stringLen;
;;;895        size_t              suffixLen;
;;;896        char *              instr_tmp;
;;;897        char *              inSuffix_tmp;
;;;898        size_t              i;
;;;899        char *              ret;
;;;900    
;;;901        suffixLen = strlen( inSuffix );
00000a  4610              MOV      r0,r2
00000c  f7fffffe          BL       strlen
000010  4605              MOV      r5,r0
;;;902        stringLen = strnlen( inStr, inMaxLen );
000012  4621              MOV      r1,r4
000014  4648              MOV      r0,r9
000016  f7fffffe          BL       strnlen
00001a  4606              MOV      r6,r0
;;;903        instr_tmp = calloc(stringLen+1, 1);
00001c  2101              MOVS     r1,#1
00001e  1c40              ADDS     r0,r0,#1
000020  f7fffffe          BL       calloc
000024  4680              MOV      r8,r0
;;;904        inSuffix_tmp = calloc(suffixLen+1, 1);
000026  2101              MOVS     r1,#1
000028  1c68              ADDS     r0,r5,#1
00002a  f7fffffe          BL       calloc
00002e  4607              MOV      r7,r0
;;;905    
;;;906        for(i=0; i<stringLen; i++)
000030  2400              MOVS     r4,#0
000032  e006              B        |L17.66|
                  |L17.52|
;;;907            instr_tmp[i] = tolower(inStr[i]);
000034  f8190004          LDRB     r0,[r9,r4]
000038  f7fffffe          BL       tolower
00003c  f8080004          STRB     r0,[r8,r4]
000040  1c64              ADDS     r4,r4,#1
                  |L17.66|
000042  42b4              CMP      r4,r6                 ;906
000044  d3f6              BCC      |L17.52|
;;;908        for(i=0; i<suffixLen; i++)
000046  2400              MOVS     r4,#0
000048  e005              B        |L17.86|
                  |L17.74|
;;;909            inSuffix_tmp[i] = tolower(inSuffix[i]);
00004a  f81a0004          LDRB     r0,[r10,r4]
00004e  f7fffffe          BL       tolower
000052  5538              STRB     r0,[r7,r4]
000054  1c64              ADDS     r4,r4,#1
                  |L17.86|
000056  42ac              CMP      r4,r5                 ;908
000058  d3f7              BCC      |L17.74|
;;;910    
;;;911        if( suffixLen <= stringLen ){
00005a  42b5              CMP      r5,r6
00005c  d80a              BHI      |L17.116|
;;;912            ret = strstr( instr_tmp, inSuffix_tmp );
00005e  4639              MOV      r1,r7
000060  4640              MOV      r0,r8
000062  f7fffffe          BL       strstr
000066  0004              MOVS     r4,r0
;;;913            if(ret != NULL)
000068  d005              BEQ      |L17.118|
;;;914                ret = (char *)(inStr+(ret-instr_tmp));
00006a  eba40108          SUB      r1,r4,r8
00006e  eb010409          ADD      r4,r1,r9
000072  e000              B        |L17.118|
                  |L17.116|
;;;915        }
;;;916        else
;;;917            ret = NULL;
000074  2400              MOVS     r4,#0
                  |L17.118|
;;;918    
;;;919        free(instr_tmp);
000076  4640              MOV      r0,r8
000078  f7fffffe          BL       free
;;;920        free(inSuffix_tmp);
00007c  4638              MOV      r0,r7
00007e  f7fffffe          BL       free
;;;921    
;;;922        return ret;
000082  4620              MOV      r0,r4
;;;923    }
000084  e8bd87f0          POP      {r4-r10,pc}
;;;924    
                          ENDP

